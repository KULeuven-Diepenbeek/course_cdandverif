[
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/000_intro/000_introduction/",
	"title": "000 Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction In these lab series a deeper dive is taken into verification. Up until now, you\u0026rsquo;ll probably (and hopefully) have made a number of testbenches. These testbenches were focussed on the behaviour of a handful of components. It is still good practise to do this. When you\u0026rsquo;re making a hardware driver for a stepper motor, it\u0026rsquo;s only common sense that you test your design.\nSomething that occurs with many beginning hardware designers is that they only test happy path. Let\u0026rsquo;s try to illustrate this with an example. Assume you made a hardware implementation of AES.\n Find a testvector Write a testbench that applies this testvector as stimuli to the design Start the simulator and run for the required amount of time Verify that the encrypted vector matches with the expected result   One swallow doesn\u0026rsquo;t make a summer.It doesn\u0026rsquo;t matter whether it\u0026rsquo;s an African or a European swallow 😉\n Many more things need to be test to be assured that the design works. What if \u0026hellip; 1) an internal register is not set to the required value after an iteration ? 2) a specific value triggers something unwanted inside ? 3) an operation is interrupted halfway through an encryption ? 4) a user applies the inputs in a different way ?\nTesting these scenario\u0026rsquo;s could (and typically will) uncover underlying shortcomings. If the design becomes more complicated, the job of the verification engineer becomes even more challenging.\nImagine this scenario:\nYou are the chief engineer of some fancy company and you're responsible for a new chip in a mobile-phone series. How can you be ensured that the chip can handle the following scenario:  The phone is playing music through some streaming app The user listens to the music through headphones which are connected through Bluetooth The battery is running low There is a handover happening between cell towers ...  ... and on that moment, there is an incoming call.  What kind of testbench would you start coding that guarantees you that the chip can handle this ?\n  In these lab series the industry standard SystemVerilog will be introduced. The verification capabilities of this language help the poor chief engineers to sign off the approval document in (relative) confidence.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/000_intro/",
	"title": "0 Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction Image courtesy: Pexels - Alexander Dummer   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/",
	"title": "1 Getting your feet wet",
	"tags": [],
	"description": "",
	"content": " Getting your feet wet Image courtesy: Pexels - Noelle Otto   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/000_intro/001_organisation/",
	"title": "001 Organisation",
	"tags": [],
	"description": "",
	"content": " Organisation These series of lab sessions will introduce you to SystemVerilog. Although this series will be taught during application colleges, the interested student can proceed at his/her own pace. If you are intrigued by the exercises, of if you prefer to continue working while the mindset is focused on the topic, you should find it possible to continue at a faster pace.\nIf you have any question, suggestion, or problem with these labs, the forum on Toledo is your place-to-go. We encourage team spirit and the idea of overcoming this challenge together.\n Content The lab sessions will focus on the following topics:\n An introduction to SystemVerilog, in chapter 1; The anatomy of a test scenario, in chapter 2; Using randomisation to increase coverage, in chapter 3; An introduction to assertions, in chapter 4.  Throughout the chapter very short exercises might be present, but you are encouraged to try out different snippets of code that are presented. There is a big difference between seeing-and-(hopefully-)understanding code, and writing it yourself.\nQuotation At the end of every chapter, there is an assignment. These assignments should be made individually and are the be handed in through the Toledo platform.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/000_intro/002_lab/",
	"title": "002 Lab",
	"tags": [],
	"description": "",
	"content": " Lab To tldr;\nTo be able to run the simulation in these labs, dedicated software is required. As SystemVerilog is not an everyday language for simulation (or verification to be more precise), we have to rely on the 3 EDA (electronic design automation) giants in industry:\n Mentor Graphics Cadence Synopsys  Due to license constraints these labs will done in QuestaSim (previously known as ModelSim), by Mentor Graphics.\nNetwork setup The design software is installed on a Virtual Machine, that is running on one of the ES\u0026amp;S servers. (As you should already know, Emerging technologies, Systems and Security (ES\u0026amp;S) is a research group within KU Leuven).\nThe networking setup is as shown in the image below.\nYour laptop is connected to the Internet, as is the chip server on which the virtual machine is running. Through a Virtual Private Network (VPN), it could appear as if your laptop is connected to the chip server on a private network. When you are connected in the VPN, you can make a connection (through another virtual network) to the virtual server that runs the design software (which sits at 10.157.37.114). This connection is to be made through an ssh-connection.\nPlease note that the ssh-server on the virtual machine is listening on port 2222, in contrast to 22 (which is the default port).\n X11 forwarding Before you get out your Putty client (or any other client), it is important to understand that we will be relying on the GUI of QuestaSim. Therefore, we need to somehow get graphical interface to be displaying on your laptop.\nApart from a VNC connection, this can (on a Linux-system) also be achieved by using X11-forwarding. If you want to learn more about the X Window System (X11 or also called X), maybe you can start at the wikipedia-page.\nIn short, what you need to do is run a X11 server on your laptop. Through the ssh connection the actual \u0026ldquo;windows\u0026rdquo; can then be displayed on your own screen. The one trick that needs to be done is to add a -X argument to the ssh connection.\n$ ssh -X -p 2222 loginname@10.157.37.114 For the Windows users it is recommended to use MobaXterm. This tool both runs an X-server and allows ssh connections. Mac users can use XQuartz to run the X-server. The ssh connection (with the -X argument) you should make through Terminal.\nTo check if you setup/configuration is working, you could use xeyes. QuestaSim Like much (professional) software that is running on a Linux machine, a script has to be run before the software can be used. Typically these scripts set some environment variables for finding the software and/or load license server settings. Although this seems as something you want to do automatically, doing this step manually allows you to load only those things that you want. For example, you could have different versions of QuestaSim running. By selecting the correct script, you can choose which version you want to work with.\nThe script you have to run once, for every login you do (meaning, for each bash session that is launched). To run the script, can do:\n$ source /opt/scripts/questasim Finally you can start QuestaSim, by using the command vsim.\n$ vsim In the appendices, some additional info on QuestaSim is available.\nTLDR;  connect to the VPN, with the files that will be given to you (individually) start the X-server software (MobXterm or XQuartz) ssh to the server with X-forwarding enabled load the environment variables run vsim  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/100_alu/",
	"title": "100 ALU",
	"tags": [],
	"description": "",
	"content": " The ALU A number of exercises will use an arithmetic and logical unit (ALU). This component is described here. As you already know (at least by only looking at the name) it performs arithmetic operations and logical operations. The ALU that is used here, is based on the GameBoy\u0026rsquo;s custom take at the Z80.\nFor this course two (or one) 8-bit operand(s) serve(s) as input and an 8-bit result is generated. Together with the operands, there is a 4-bit vector that contains flags.\n Zero Flag (Z) (3): Set when the result of an arithmetic operation is zero; or if the comparison of two values matches. Subtract Flag (N) (2): Set if a subtraction was performed in the last arithmetic operation. Half Carry Flag (H) (1): Set if a carry occurred from lower to higher nibble in the last arithmetic operation Carry Flag (C) (0): Set if a carry occurred in the last arithmetic operation; or if the A-operand is smaller when executing a compare.  Off course there is a 3-bit operation selection to select what the output should produce.\nArithmetic operations  (000) Add (001) Add with carry (010) Subtract (011) Subtract with carry   Logical operations  (100) Logical AND (101) Logical XOR (110) Logical OR (111) Compare    -------------------------------------------------------------------------------- -- KU Leuven - ESAT/COSIC- Embedded Systems \u0026amp; Security -------------------------------------------------------------------------------- -- Module Name: ALU - Behavioral -- Project Name: CD and Verif -- Description: The ALU that will be tested on -- -- Revision Date Author Comments -- v0.1 20210311 VlJo Initial version -- -------------------------------------------------------------------------------- library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ALU is port ( A : in STD_LOGIC_VECTOR(7 downto 0); B : in STD_LOGIC_VECTOR(7 downto 0); flags_in : in STD_LOGIC_VECTOR(3 downto 0); Z : out STD_LOGIC_VECTOR(7 downto 0); flags_out : out STD_LOGIC_VECTOR(3 downto 0); operation: in STD_LOGIC_VECTOR(2 downto 0) ); end ALU; architecture Behavioural of ALU is signal A_i, B_i, B_ii, Z_i : STD_LOGIC_VECTOR(7 downto 0); signal C_i : STD_LOGIC; signal Zfl_i, Nfl_i, Hfl_i, Cfl_i : STD_LOGIC; signal Zfl_o, Nfl_o, Hfl_o, Cfl_o : STD_LOGIC; signal operation_i : STD_LOGIC_VECTOR(2 downto 0); signal sum, carry : STD_LOGIC_VECTOR(7 downto 0); signal l_and, l_xor, l_or : STD_LOGIC_VECTOR(7 downto 0); begin ------------------------------------------------------------------------------- -- (DE-)LOCALISING IN/OUTPUTS ------------------------------------------------------------------------------- A_i \u0026lt;= A; B_i \u0026lt;= B; Zfl_i \u0026lt;= flags_in(3); Nfl_i \u0026lt;= flags_in(2); Hfl_i \u0026lt;= flags_in(1); Cfl_i \u0026lt;= flags_in(0); operation_i \u0026lt;= operation; Z \u0026lt;= Z_i; ------------------------------------------------------------------------------- -- OUTPUT SELECTION ------------------------------------------------------------------------------- PMUX: process(operation_i, A_i, B_i, sum, Cfl_i, Zfl_o, Hfl_o, Cfl_o, l_and, l_xor, l_or) begin B_ii \u0026lt;= B_i; case operation_i is when \u0026#34;001\u0026#34; =\u0026gt; -- ADC =\u0026gt; N is always zero Z_i \u0026lt;= sum; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;0\u0026#39; \u0026amp; Hfl_o \u0026amp; Cfl_o; C_i \u0026lt;= Cfl_i; when \u0026#34;010\u0026#34; =\u0026gt; -- SUB =\u0026gt; N is always one Z_i \u0026lt;= sum; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;1\u0026#39; \u0026amp; not(Hfl_o) \u0026amp; not(Cfl_o); B_ii \u0026lt;= not(B_i); C_i \u0026lt;= \u0026#39;1\u0026#39;; when \u0026#34;011\u0026#34; =\u0026gt; -- SBC =\u0026gt; N is always one Z_i \u0026lt;= sum; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;1\u0026#39; \u0026amp; not(Hfl_o) \u0026amp; not(Cfl_o); B_ii \u0026lt;= not(B_i); C_i \u0026lt;= not(Cfl_i); when \u0026#34;100\u0026#34; =\u0026gt; -- AND Z_i \u0026lt;= l_and; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;0\u0026#39; \u0026amp; \u0026#39;1\u0026#39; \u0026amp; \u0026#39;0\u0026#39;; when \u0026#34;101\u0026#34; =\u0026gt; -- XOR Z_i \u0026lt;= l_xor; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;0\u0026#39; \u0026amp; \u0026#39;0\u0026#39; \u0026amp; \u0026#39;0\u0026#39;; C_i \u0026lt;= \u0026#39;0\u0026#39;; when \u0026#34;110\u0026#34; =\u0026gt; -- OR Z_i \u0026lt;= l_or; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;0\u0026#39; \u0026amp; \u0026#39;0\u0026#39; \u0026amp; \u0026#39;0\u0026#39;; C_i \u0026lt;= \u0026#39;0\u0026#39;; when \u0026#34;111\u0026#34; =\u0026gt; -- CP Z_i \u0026lt;= A_i; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;1\u0026#39; \u0026amp; not(Hfl_o) \u0026amp; not(Cfl_o); B_ii \u0026lt;= not(B_i); C_i \u0026lt;= \u0026#39;1\u0026#39;; when others =\u0026gt; Z_i \u0026lt;= sum; flags_out \u0026lt;= Zfl_o \u0026amp; \u0026#39;0\u0026#39; \u0026amp; Hfl_o \u0026amp; Cfl_o; B_ii \u0026lt;= B_i; C_i \u0026lt;= \u0026#39;0\u0026#39;; end case; end process; ------------------------------------------------------------------------------- -- Arithmetic operations ------------------------------------------------------------------------------- RCA: for i in 0 to 7 generate LSB: if i=0 generate sum(i) \u0026lt;= A_i(i) xor B_ii(i) xor C_i; carry(i) \u0026lt;= (A_i(i) and B_ii(i)) or (C_i and (A_i(i) xor B_ii(i))); end generate LSB; OTHER: if i\u0026gt;0 generate sum(i) \u0026lt;= A_i(i) xor B_ii(i) xor carry(i-1); carry(i) \u0026lt;= (A_i(i) and B_ii(i)) or (carry(i-1) and (A_i(i) xor B_ii(i))); end generate OTHER; end generate RCA; ------------------------------------------------------------------------------- -- Logical operations ------------------------------------------------------------------------------- l_and \u0026lt;= A_i and B_ii; l_xor \u0026lt;= A_i xor B_ii; l_or \u0026lt;= A_i or B_ii; ------------------------------------------------------------------------------- -- FLAG DETERMINATION ------------------------------------------------------------------------------- Zfl_o \u0026lt;= \u0026#39;1\u0026#39; when Z_i = x\u0026#34;00\u0026#34; else \u0026#39;0\u0026#39;; Nfl_o \u0026lt;= \u0026#39;1\u0026#39; when sum(7) = \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; Hfl_o \u0026lt;= carry(3); Cfl_o \u0026lt;= carry(7); end Behavioural; "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/101_testing/",
	"title": "101 Testing",
	"tags": [],
	"description": "",
	"content": " ALU testing In earlier years you have used the classical way of simulating your designs: with testbenches.\nYour design is instantiated in a higher entity and is referred to with the device under test (DUT). A number of stimuli are generated and are fed to the DUT. These stimuli can range from rather simple to very complex accurate models of certain signal sources.\nThe output of the DUT is monitored to determine whether the implementation behaves as is expected (or hoped for 😃). The results could be inspect visually (in waveforms), or they can be interpreted by (again) certain models.\nA very useful technique (both for generating and validating) is the use of files. You(r script) create(s) a file with inputs, and you(r script) compare(s) the output files with a golden reference.\nAn extremely simple example of such a testbench is shown below.\n-------------------------------------------------------------------------------- -- KU Leuven - ESAT/COSIC- Embedded Systems \u0026amp; Security -------------------------------------------------------------------------------- -- Module Name: ALU_tb - Behavioral -- Project Name: CD and Verif -- Description: Classic testbench example on the ALU -- -- Revision Date Author Comments -- v0.1 20210311 VlJo Initial version -- -------------------------------------------------------------------------------- library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity ALU_tb is end ALU_tb; architecture Behavioural of ALU_tb is signal clock : STD_LOGIC; component ALU is port ( A : in STD_LOGIC_VECTOR(7 downto 0); B : in STD_LOGIC_VECTOR(7 downto 0); flags_in : in STD_LOGIC_VECTOR(3 downto 0); Z : out STD_LOGIC_VECTOR(7 downto 0); flags_out : out STD_LOGIC_VECTOR(3 downto 0); operation: in STD_LOGIC_VECTOR(2 downto 0) ); end component; signal a, b, z : STD_LOGIC_VECTOR(7 downto 0); signal flags_in, flags_out : STD_LOGIC_VECTOR(3 downto 0); signal operation : STD_LOGIC_VECTOR(2 downto 0); constant clock_period : time := 10 ns; begin ------------------------------------------------------------------------------- -- STIMULI ------------------------------------------------------------------------------- PSTIM: process begin ------------------------------------------------------------------------------- -- TESTING ADDITION WITH FLAGS ------------------------------------------------------------------------------- A \u0026lt;= x\u0026#34;00\u0026#34;; B \u0026lt;= x\u0026#34;00\u0026#34;; operation \u0026lt;= \u0026#34;000\u0026#34;; flags_in \u0026lt;= \u0026#34;0000\u0026#34;; wait for clock_period; assert(Z = x\u0026#34;00\u0026#34;) report \u0026#34;error in result\u0026#34; severity failure; -- Zfl Nfl Hfl Cfl assert(flags_out = \u0026#34;1000\u0026#34;) report \u0026#34;error in result\u0026#34; severity failure; wait for clock_period; A \u0026lt;= x\u0026#34;20\u0026#34;; B \u0026lt;= x\u0026#34;22\u0026#34;; operation \u0026lt;= \u0026#34;000\u0026#34;; wait for clock_period; assert(Z = x\u0026#34;42\u0026#34;) report \u0026#34;error in result\u0026#34; severity failure; assert(flags_out = \u0026#34;0000\u0026#34;) report \u0026#34;error in result\u0026#34; severity failure; wait for clock_period; wait for clock_period*1000; end process; ------------------------------------------------------------------------------- -- DEVICE UNDER TEST ------------------------------------------------------------------------------- DUT: component ALU port map( A =\u0026gt; A, B =\u0026gt; B, flags_in =\u0026gt; flags_in, Z =\u0026gt; Z, flags_out =\u0026gt; flags_out, operation =\u0026gt; operation ); ------------------------------------------------------------------------------- -- CLOCK ------------------------------------------------------------------------------- PCLK: process begin clock \u0026lt;= \u0026#39;1\u0026#39;; wait for clock_period/2; clock \u0026lt;= \u0026#39;0\u0026#39;; wait for clock_period/2; end process; end Behavioural; This could be fine for a couple of simple unit tests while developing. When designs become more complex, this will not scale.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/102_systemverilog/",
	"title": "102 SystemVerilog",
	"tags": [],
	"description": "",
	"content": " ALU testing - with SystemVerilog After the introductions of VHDL and Verilog in earlier courses, it is time to visit the new kind on the block: SystemVerilog. Although, new is relative. SystemVerilog has first appeared in 2002 and is a part of the IEEE standard since 2008. VHDL has first appeared in 1980 and Verilog in 1984.\nBoth VHDL and Verilog are hardware description languages (HDL). The idea is you use the language to describe the design you made. SystemVerilog is also a hardware description language, but it is also a hardware verification language (HVL).\nAlthough SystemVerilog can be used as an HDL, in these labs the focus lies on the HVL.\n Synthesizable vs Non-synthesizable code In the earlier HDL courses a distinction was made between synthesizable and non-synthesizable code. The former is code can, as the names states, be run through the synthesis tool. In other words, you describe something that can be built with standard cells (ASIC) or can be implemented in reconfigurable fabric (FPGA).\nSynthesizable PREG: process (clock) begin if rising_edge(clock) then if reset = \u0026#39;1\u0026#39; then regX \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); else if load_reg = \u0026#39;1\u0026#39; then regX \u0026lt;= regX_i; elsif shiftL_reg = \u0026#39;1\u0026#39; then regX \u0026lt;= regX(regX\u0026#39;high-1 downto 0) \u0026amp; \u0026#39;0\u0026#39;; end if; end if; end if; end process;   Non-synthesizable PSTIM: process begin regX_i \u0026lt;= x\u0026#34;AB12\u0026#34;; load_reg \u0026lt;= \u0026#39;0\u0026#39;; shiftL_reg \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; shiftL_reg \u0026lt;= \u0026#39;1\u0026#39;; wait for 10 ns; shiftL_reg \u0026lt;= \u0026#39;0\u0026#39;; wait for 10 ns; wait; end process;    Both in VHDL and Verilog, non-synthesisable code is valid, but only for testbenches. The SystemVerilog language has a much larger part that is for verification only.\nThe image below occurred in a paper by Sutherland and Mills (link to the article). It shows the versions and added keywords to Verilog through time. Every rectangle is backward compatible with all the inner rectangles.\n  Verilog to SystemVerilog growth chart   The outer rectangle (SystemVerilog-2005/2009/2012) shows what was added by SystemVerilog. The added keywords/concepts are separated in design and verification. This illustrates SystemVerilog being both a HDL and HVL, and distinguishes the synthesizable and non-synthesisable code.\nThese labs have no intention of going over all the different keywords and making small exercises on each of them. The idea is that the concepts are addressed and the keywords will make their introduction as we go.\n One keyword, however, is important to spot: classes.\nObject-oriented approach With SystemVerilog you will no longer write a testbench. You rather write software that generates the testbenches, apply them, and only examine the results.\nMost of the techniques you learned in software courses can be applied here. Well known functions in the OO-world are featured in SystemVerilog:\n Inheritance Polymorphism Encapsulation Abstract type modelling  A user-defined class becomes a data type and can have properties (= class data), and methods (= class methods).\n// class declaration class ExampleClass; // data members - class properties  int x; // class methods  function set(int i); x = i; end function function int get(); return x; end function endclass   // make an instance ExampleClass ec1; ec1 = new; // make an instance in another way ExampleClass ec2 = new;    With this OO-approach, the developed code can be reused more efficiently.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/103_interfaces/",
	"title": "103 Interfaces",
	"tags": [],
	"description": "",
	"content": " Interfaces Well, all of the above sounds very nice and understandable, but if you think it through questions will arise (and will keep arising ever more 😉).\nThe first question that needs answering before we can go to an example is: \u0026ldquo;How do you connect this software to the hardware ?\u0026rdquo;. The answer is very short, but way from simple: interfaces.\nLet\u0026rsquo;s take a look at the entity of ALU and try if we can figure this out.\nentity ALU is port ( A : in STD_LOGIC_VECTOR(7 downto 0); B : in STD_LOGIC_VECTOR(7 downto 0); flags_in : in STD_LOGIC_VECTOR(3 downto 0); Z : out STD_LOGIC_VECTOR(7 downto 0); flags_out : out STD_LOGIC_VECTOR(3 downto 0); operation: in STD_LOGIC_VECTOR(2 downto 0) ); end ALU; \nThere are 4 inputs to the ALU and 2 outputs. The inputs need to be driven by the testing environment, and (off course) the outputs need to be evaluated by the testing environment. With an interface, a sort of plug is described. This plug can be inserted into the DUT and into the software-based testing environment.\nAlthough, in essence, this is correct, an interface can provide much more features.\n \nThe alongside code shows a simple interface. Instead of defining a module, an interface is defined: ALU_iface. The interface in the example has one input: the clock. Although a clock is common, it is not mandatory.\nNext, there is a definition for every signal or bus inside the interface. Note that there is no direction specified.\nAnother remark on the signals is the type. Further down, this is elaborated on.\nFinally, the C-programmers might recognise the \u0026lsquo;ifndef, \u0026lsquo;define, and \u0026lsquo;endif directives. These work in a similar way. With including source files, this construction prevents multiple iterations over the same code.\n `ifndef SV_IFC_ALU `define SV_IFC_ALU  interface ALU_iface ( input logic clock ); logic [7:0] data_a; logic [7:0] data_b; logic [7:0] data_z; logic [3:0] flags_in; logic [3:0] flags_out; logic [2:0] operation; endinterface `endif  \n\nUse logic rather than wire or reg One of the big stumbling stones in Verilog is the difference between wire and reg. SystemVerilog has made things easier with defining a new data type: logic. Also, Verilog and VHDL natively have types that support four basic states:\n0 1 X Z  Datatypes As we are discussing data types, this might the place to add a list on the different data types. SystemVerilog has a number of data types that have only two states:\n0 1  In simulation it makes less sense to keep four-state values.\nTwo-state datatypes  bit: 1 bit byte: 8 bits (similar to char in C) shortint: 16 bits (similar to short in C) int: 32 bits (similar to int in C) longint: 64 bits (similar to longlong C)   Four-state datatypes  logic: 1 bit (similar to reg/wire in Verilog) integer: 32 bits   \nIt is important to understand that at some level a switch is made between a 2-state and a 4-state data type. The table below shows how this translation is done.\nTwo-stateFour-state 1\u0026nbsp;1 0\u0026nbsp;0 0\u0026nbsp;X 0\u0026nbsp;Z  Strings SystemVerilog adds the typical string datatype to the language, eg. string foo = \u0026quot;bar\u0026quot;;. It haves mostly like in any other software language you have seen: There is comparison, replication, concatenation, \u0026hellip; Also, there a number of functions/tasks that can help in manipulating strings: chipverify.com.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/104_helloworld/",
	"title": "104 Hello world",
	"tags": [],
	"description": "",
	"content": " Hello world Let\u0026rsquo;s put the introduction to a pause and look at some code !!\nThe example below shows a very simple test. The DUT only performs an inversion of the 8 incoming bits, when the data valid is high. The inverted result is stored in a register which is routed to the output of the DUT.\nThe image below shows the architecture that is constructed for the example.\nLife will become more complicated (very soon), but for now the example is stored in a single file.\n/*** * The interface ***/ interface demo_iface ( input logic clock ); logic [7:0] data_in; logic data_valid; logic [7:0] data_out; endinterface /*** * The DUT ***/ module inverting_register(demo_iface di); always @(posedge di.clock) begin if(di.data_valid) di.data_out \u0026lt;= ~di.data_in; end endmodule /*** * Test environment ***/ module Top; logic clock=0; // clock generation - 100 MHz  always #5 clock = ~clock; // instantiate an interface  demo_iface theInterface ( .clock(clock) ); // instantiate the DUT and connect it to the interface  inverting_register dut ( .di(theInterface) ); // provide stimuli  initial begin theInterface.data_in \u0026lt;= 8\u0026#39;h0; theInterface.data_valid \u0026lt;= 1\u0026#39;b0; repeat (10) @(posedge clock); theInterface.data_in \u0026lt;= 8\u0026#39;h12; theInterface.data_valid \u0026lt;= 1\u0026#39;b1; @(posedge clock); theInterface.data_valid \u0026lt;= 1\u0026#39;b0; @(posedge clock); theInterface.data_in \u0026lt;= 8\u0026#39;h55; theInterface.data_valid \u0026lt;= 1\u0026#39;b1; @(posedge clock); theInterface.data_valid \u0026lt;= 1\u0026#39;b0; @(posedge clock); repeat (1000) @(posedge clock); $finish; end endmodule  \nInterface First the interface is defined. There are 3 signals, two of which are 8-bit buses. Also, there is an incoming clock which is declared.\nDUT The DUT itself is very simple. The register, with a chip enable, acts upon a rising edge of the clock.\nNote that the ports of the component are declared through the interface.\nTop Finally, the Top module:\n generates a clock, instantiates an interface, connects the interface to the DUT, and, provides stimuli   \nSimulating the code above, produces a waveform as can be seen in the image below.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/100_wetfeet/105_assignment/",
	"title": "105 Assignment 1",
	"tags": [],
	"description": "",
	"content": " Assignment 1 The first assignment is to write, analogous to the given example, a simple testbench. The DUT is the ALU that was seen earlier.\nYou only need to test the addition: Keep one operand fixed to 0x01 and have the other operand loop over all 256 possible values.\nAfter this chapter you should \u0026hellip;  ... have your development and simulation environment set up (efficiently) ... have gotten your hands dirty ... have some experience using mixing languages ... have a basic understanding of how SystemVerilog communicates with the hardware   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/200_increase/",
	"title": "2 Adding some registers",
	"tags": [],
	"description": "",
	"content": " Adding some registers Image courtesy: Pexels - Monstera   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/200_increase/201_registerfile/",
	"title": "201 Register file",
	"tags": [],
	"description": "",
	"content": " Register file With our first experiments done, it is time to add some registers. Typically a processor has an array of registers inside to be used during operation: the register file. The GameBoy CPU has eight 8-bit registers and two 16-bit registers. The 8-bit registers are labeled: A, B, C, D, E, F, H, and L. The 16-bit registers are the program counter (PC) and the stack pointer (SP). We\u0026rsquo;re not going to bother with the memory in which the programs reside, so we can forget about the latter two. With this comes that the 16-bit operations also fall out-of-scope with respect to verification in this course.\nTwo 8-bit registers deserve some additional explanation: register A, and register F.\nRegister F This register is used to store the 4 flags: Z, N, H, and C. They are positioned on the left-hand side, so the 4 least significant bits are always set to 0. We discussed these flag in the beginning of these lab sessions ALU.\nRegister A Register A works a sort of accumulator register. The instructions for the ALU always use the A register as an operand, and the result of the ALU-operation is stored back in register A.\nOther registers Off course the other registers are equally important. These registers can also be LOADED through machine-code instructions like LD B, L (e.g. load the value of register L into register B). As we want to stay focused on the ALU operations, the load instructions are left out of scope. This, however, would turn the other registers rather pointless, as we can not load any values in them. Therefore they are preloaded with fixed values. Please mind, this is not a correct model of the actual processor, but it will keep things a little more simple.\n ... /* REGISTERS */ always_ff @(posedge clock) begin if (reset) begin regA = 8\u0026#39;h0; regB = 8\u0026#39;h1; regC = 8\u0026#39;h2; regD = 8\u0026#39;h3; regE = 8\u0026#39;h4; regF = 8\u0026#39;h0; regH = 8\u0026#39;h5; regL = 8\u0026#39;h6; end else begin if (load_regA == 1\u0026#39;b1) regA = alu_Z; if (load_regF == 1\u0026#39;b1) regF = { alu_flags_out, 4\u0026#39;h0 }; end end ...  \n\nBringing the DUT together The DUT, in the previous chapter, only existed out of the ALU. Now it will also have the register file. With both components together, the DUT is ready for testing.\nSince there is sequential logic in the new DUT, there is a need to add a clock and a reset signal. To indicate which operation the DUT has to execute, an 8-bit instruction is also added together with a valid signal. It should be clear that an instruction is only to be execute when the valid signal is high.\nWith this arrangement it will be easy to give instructions to the DUT. However, as these labs focus on verification there should also be a way to see what the DUT generated. For this purpose (and given the simplicity of the DUT) a probe can done on registers A and F.\nA word on the operation The machine-level instructions in the GameBoy are 8 bits in width. Until now, only 3 bits were used to indicate an instruction for the ALU. Another 3 bits are required to make a selection on the second operand. This totals to 6 bits. So \u0026hellip; we\u0026rsquo;re missing 2 bits. Luckily for us, (almost) all the operations that involve the ALU start with \u0026ldquo;10\u0026rdquo;. This can be seen nicely on (this webpage).\nAs an example the operation ADC H is used. This operation takes whatever is present in register A and adds register H. The sum is then stored again in register A. The possible carry-flag from the previous operation is also added in the sum.\nAs this operation is an ALU instruction it starts with \u0026ldquo;10\u0026rdquo;. The operation ADC is represented with \u0026ldquo;001\u0026rdquo;. Finally, the selection of the second operand H comes down to appending \u0026ldquo;100\u0026rdquo;. This results in the binary code: 10001100.\nOn the operand selection there is an option to choose (HL). This notation indicates there is indirect addressing. The value of this operand is the content which is stored at the address that is formed by concatenating the values of H and L.   In this lab setup, this value is ignored as the memory is out of scope for these labs.\n The resulting DUT The DUT as shown above, can be described as follows.\n//------------------------------------------------------------------------------ // KU Leuven - ESAT/COSIC- Embedded Systems \u0026amp; Security //------------------------------------------------------------------------------ // Module Name: gbprocessor - Behavioral // Project Name: CD and Verif // Description: The processor, containing the ALU and registers // // Revision Date Author Comments // v0.1 20211322 VlJo Initial version // //------------------------------------------------------------------------------  module gbprocessor ( input reset, input clock, input [7:0] instruction, input valid, output [2*8-1:0] probe ); logic [7:0] regA, regB, regC, regD, regE, regF, regH, regL; logic load_regA, load_regF; logic [7:0] alu_B, alu_Z; logic [3:0] alu_flags_out; assign load_regA = instruction[7] \u0026amp; ~instruction[6] \u0026amp; valid; assign load_regF = instruction[7] \u0026amp; ~instruction[6] \u0026amp; valid; assign probe = {regA, regF}; /* second operand selector MUX */ always_comb begin case(instruction[2:0]) 3\u0026#39;h0: alu_B \u0026lt;= regB; 3\u0026#39;h1: alu_B \u0026lt;= regC; 3\u0026#39;h2: alu_B \u0026lt;= regD; 3\u0026#39;h3: alu_B \u0026lt;= regE; 3\u0026#39;h4: alu_B \u0026lt;= regH; 3\u0026#39;h5: alu_B \u0026lt;= regL; 3\u0026#39;h6: alu_B \u0026lt;= 8\u0026#39;h0; default: alu_B \u0026lt;= regA; endcase end /* ALU */ ALU ALU_inst00( .A(regA), .B(alu_B), .flags_in(regF[7:4]), .operation(instruction[5:3]), .Z(alu_Z), .flags_out(alu_flags_out)); /* REGISTERS */ always_ff @(posedge clock) begin if (reset) begin regA = 8\u0026#39;h0; regB = 8\u0026#39;h1; regC = 8\u0026#39;h2; regD = 8\u0026#39;h3; regE = 8\u0026#39;h4; regF = 8\u0026#39;h0; regH = 8\u0026#39;h5; regL = 8\u0026#39;h6; end else begin if (load_regA == 1\u0026#39;b1) regA = alu_Z; if (load_regF == 1\u0026#39;b1) regF = { alu_flags_out, 4\u0026#39;h0 }; end end endmodule  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/200_increase/202_test/",
	"title": "202 Updating test",
	"tags": [],
	"description": "",
	"content": " Updating the test Adding more features to the DUT is all nice, but this has to be reflected in the verification.\nAs the DUT now looks different, the interface needs to be adapted. It no longer connects to the ALU, but to the gbprocessor.\nInitially, register A starts at value 0x00. When the instruction ADC H is executed, then register A gets incremented with 5.\nHave a closer look at the waveforms. After the ADC operation, the value of register A is updated. However, this results in a consecutive change of the ALU output \u0026lsquo;Z\u0026rsquo;.Why is this new value not stored in register A ?\n Repeating this instruction 3 more times will result in a change of the value in register F.\nFind an explanation why register F changes.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/200_increase/203_practice/",
	"title": "203 Practice",
	"tags": [],
	"description": "",
	"content": " Practice This is no assignment but some practice. Start by copying the code you have from the first lab. Modify the new DUT so it incorporates the registers as described in this chapter.\nNow, experiment with the instructions. Try different values and verify that the DUT behaves the way it is intended to.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/",
	"title": "3 Climbing the OO ladder",
	"tags": [],
	"description": "",
	"content": " Climbing the OO ladder Image courtesy: Pexels - Uriel Mont   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/301_layered_testbench/",
	"title": "301 Layered testbench",
	"tags": [],
	"description": "",
	"content": " Layered testbench Some of you might be thinking: \u0026ldquo;That assignment and those exercises did not differ too much from the classical approach.\u0026rdquo;. If so, you\u0026rsquo;re right. From this point on, however, the layered testbench will be climbed.\nThe concept in SystemVerilog is to build a layered testbench:\n Signal layer: The bottom-most layer is the signal layer. On this level only the DUT resides. The signals that going to and from the DUT represent actual signals. Aspects like rise-times and clock cycles are important only on this level. This level mainly serves connectivity. Command layer: The second layer is the command layer. This is an edge layer that translates signals from the software world into physical signals. This includes translations to conceptual interfaces like AXI4Stream. Transactions are done, in two directions, by the driver and the monitor. Assertions will be handled more thoroughly, later. Functional level: At this level of abstraction, the tester no longer concerns himself/herself with signals and protocols, but focuses on the application level. Coming up with questions and determining the answer is done here. Also the checking of the observed outcome to the correct answer happens here. Finally, this layer keeps score 😃 Scenario: The highest level of abstraction is the scenario layer. In this layer different scenarios can be checked (what a surprise). Everybody should be familiar with happy path (when everything happens as it should, nobody is breaking any rules, nor trying to). A scenario where every 1% of the time something happens can be tested on this level, as example. Control: Finally, an overarching layer controls all the layers.  Going step-by-step During the first assignment, you\u0026rsquo;ve driven the DUT directly. A total of 256 different testvectors were thrown at the DUT. The next step is to do this in a more SystemVerilog-like way.\nclass driver; /* Virtual interface */ virtual gbprocessor_iface ifc; /* Constructor */ function new(virtual gbprocessor_iface ifc); this.ifc = ifc; endfunction : new /* run_addition method */ task run_addition(); string s; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); /* format timing */ /* print message */ s = $sformatf(\u0026#34;[%t | DRV] I will start driving for addition\u0026#34;, $time); $display(s); /* start with reset */ this.ifc.reset \u0026lt;= 1\u0026#39;b1; repeat(10) @(posedge this.ifc.clock); this.ifc.reset \u0026lt;= 1\u0026#39;b0; repeat(10) @(posedge this.ifc.clock); /* execute instructions */ this.ifc.valid \u0026lt;= 1\u0026#39;b1; this.ifc.instruction \u0026lt;= 8\u0026#39;h81; @(posedge this.ifc.clock); this.ifc.valid \u0026lt;= 1\u0026#39;b1; this.ifc.instruction \u0026lt;= 8\u0026#39;h82; @(posedge this.ifc.clock); this.ifc.valid \u0026lt;= 1\u0026#39;b0; this.ifc.instruction \u0026lt;= 8\u0026#39;h00; @(posedge this.ifc.clock); /* print message */ s = $sformatf(\u0026#34;[%t | DRV] done\u0026#34;, $time); $display(s); endtask : run_addition endclass : driver  \nBehold \u0026hellip; the first class: driver.\nAs you might recognise from other OO-languages, this class \u0026lsquo;driver\u0026rsquo; has:\n a single property ifc, one constructor new( ), and a single class method run_addition( ).  It is pointed out that the this keyword should be used to distinguish between a local variable and a class member. In the line this.ifc = ifc; the left-hand ifc targets the class member. The right-hand occurrence of ifc targets the local variable that was given as a function argument.\nIn the example, there is only one method run_addition(). When this method is called, it resets the DUT and then gives it 2 instructions.\n \nFinally, there is one more important keyword: virtual. In SystemVerilog the interface is considered static. This makes sense as there should be only one interface that connects the test environment with the DUT. Classes, in contrast, are dynamic by nature. This also comes natural as class instances (or objects) are created dynamically.\nBecause of this duality, it is not allowed to declare an interface within a class. The solution for this is to work with a placeholder that will be substituted with the actual interface. This is achieved by the virtual keyword. A virtual interface is a variable of a certain interface type that is used to facilitate access to the interface from within in a class.\nTL;DR \u0026nbsp; for the interface: use virtual.\n Building the testbench Keeping in mind one of the big benefits from SystemVerilog, being modularity and re-usability, it should not come as a surprise that the amount of files and hierarchy is substantial. Don\u0026rsquo;t let that scare you !! The image below shows a simple example.\nThe highest block is the testbench: top(.sv). On the righthand-side there is the gbprocessor(.sv). Note that the design itself could also consist of many files. The interface, ALU_iface(.sv), is already discussed but is now simply stored in a separate file.\nThe software is all contained and managed by test(.sv). For now, the only thing this does is instantiating an environment(.sv). The purpose of this environment will become clear later on in these labs. Finally, the only thing the environment currently does is instantiating the driver(.sv).\nHehe, that was a lot of files and a seemingly pointless hierarchy. Below are basic examples of: top.sv, test.sv, and environment.sv.\n function openTab(evt, tabName) { // Declare all variables var i, tabcontent, tablink; // Get all elements with class=\"tabcontent\" and hide them tabcontent = document.getElementsByClassName(\"tabcontent\"); for (i = 0; i top.sv test.sv environment.sv  `include \u0026#34;gbprocessor_iface.sv\u0026#34; `include \u0026#34;test.sv\u0026#34; module top; logic clock=0; // clock generation - 100 MHz  always #5 clock = ~clock; // instantiate an interface  gbprocessor_iface gb_iface ( .clock(clock) ); // instantiate the DUT and connect it to the interface  gbprocessor dut ( .reset(gb_iface.reset), .clock(clock), .instruction(gb_iface.instruction), .valid(gb_iface.valid), .probe(gb_iface.probe) ); // SV testing  test tst(gb_iface); endmodule : top  \n`include \u0026#34;gbprocessor_iface.sv\u0026#34; `include \u0026#34;environment.sv\u0026#34; program test (gbprocessor_iface ifc); environment env = new(ifc); initial begin env.run(); end endprogram : test  \n`include \u0026#34;driver.sv\u0026#34; class environment; virtual gbprocessor_iface ifc; driver drv; function new(virtual gbprocessor_iface ifc); this.drv = new(ifc); endfunction : new /* Task : run * Parameters : * Returns : **/ task run(); this.drv.run_addition(); endtask : run endclass : environment  \nIf you add the driver.sv, as illustrated above, you can start running the simulator. The result of this should look like shown below.\nNow you try this !! "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/302_monitor/",
	"title": "302 Adding a monitor",
	"tags": [],
	"description": "",
	"content": " Adding a monitor With our scaffolding starting to take form, it\u0026rsquo;s time to start filling the reserved spots. First up is the monitor. As you might recall from the previous section, the Monitor resides on the Command layer and receives data from the DUT. This way SystemVerilog can evaluate how the DUT handled the given inputs.\nclass monitor; /* Virtual interface */ virtual gbprocessor_iface ifc; /* Constructor */ function new(virtual gbprocessor_iface ifc); this.ifc = ifc; endfunction : new /* run method */ task run(); string s; byte a, b, z; bit sample = 0; byte instruction; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); /* format timing */ /* print message */ s = $sformatf(\u0026#34;[%t | MON] I will start monitoring\u0026#34;, $time); $display(s); forever begin /* wait for falling edge of the clock */ @(negedge this.ifc.clock); /* if sampling is required, sample */ if(sample == 1) begin s = $sformatf(\u0026#34;[%t | MON] I sampled %x (with %x)\u0026#34;, $time, this.ifc.probe, instruction); $display(s); sample = 0; end /* determine whether sampling is required */ if(this.ifc.valid == 1) begin sample = 1; instruction = this.ifc.instruction; end /* if valid */ end /* forever */ endtask : run endclass : monitor  \nThis code shows a minimal implementation for a monitor.\nA number of remarks were already made for the driver:\n the class the class property for the interface. Note that the type is again a virtual interface. a constructor function a run task  The main difference with the driver code (for now) is the forever loop. Once the monitor has started, it\u0026rsquo;ll keep on working until the end of time (or shut down).\nHere it becomes a little tricky: the value of the probe only changes 1 clock cycle after a valid instruction. Therefore, samling is only done if there was valid instruction in the previous clock cycle.\nThe first step is to wait on a negedge off the clock. Once this has been detected, sampling will be done, if the previous clock cycle was a meaningful instruction.\nAfter (possible) sampling, it has to be determined whether or not sampling is required in the NEXT clock cycle.\n \nThere is a simple line of code that could have great impact: instruction = this.ifc.instruction As is already explained earlier there are 2-state and 4-state variables. If you remember, a byte is an eight bit 2-state value; and the pins from the DUT (being described in HDL) are a 4-state type. Don\u0026rsquo;t get fooled by this !!\nSome help As this could become tricky, SystemVerilog also adds a number of operators. These can come in handy when having to deal with these translations between 2-state and 4-state values.\n === true if equal (with X and Z included) !== true if not equal (with X and Z included) ==? true if equal (with X and Z as wildcard) !=? true if not equal (with X and Z as wildcard)   What would be the output of this code ?\n module operators_demo; logic [3:0] a, b; initial begin a = 4\u0026#39;b1001; b = 4\u0026#39;b10X1; if (a ==? b) $display(\u0026#34;YES\u0026#34;); if (a !== b) $display(\u0026#34;YES\u0026#34;); end endmodule  \n\nIntegrating the monitor Now, with the first version of the monitor ready-and-understood, it has be inserted into the test. It should not come as a surprise that it will reside in the environment, next to the driver.\n`include \u0026#34;driver.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; class environment; virtual gbprocessor_iface ifc; driver drv; monitor mon; function new(virtual gbprocessor_iface ifc); this.drv = new(ifc); this.mon = new(ifc); endfunction : new task run(); this.drv.run_addition(); this.mon.run(); endtask : run endclass : environment  \nWith all that tackled, the monitor can be added in the environment.\nNext is the code for the run( ) task inside the environment. This will run the correct methods in both the driver and the monitor.\n\n\nNow you try this !!   \nThis will fail. Although you might have already spotted why, this will be discussed in the next section.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/303_joinorfail/",
	"title": "303 Join or fail",
	"tags": [],
	"description": "",
	"content": " Join or fail So \u0026hellip; you noticed that the final exercise failed, didn\u0026rsquo;t you ?\nThis is due to the fact that we are simulating hardware in software. More precisely, we\u0026rsquo;re simulating hardware that runs everything in parallel. The simulation is done in software, which typically is sequential.\nNow how to fix this ?\nEnter concurrent processes To achieve support for parallel pieces of software, threads can be used. In Verilog2001 the fork\u0026hellip;join construct was added. SystemVerilog adds two additional variants: fork\u0026hellip;join_any and fork\u0026hellip;join_none. How this multi-threaded approach works, can be explained easiest with a drawing.\nLet\u0026rsquo;s assume there are four \u0026ldquo;tasks\u0026rdquo; in software: a, b, c, and d. Note that this can also be a function or method call, or a simple one-line statement. Simply writing \u0026nbsp; a; b; c; d; will start task a. When this is done, task b will be started, and so on.\nTo start every task in its own dedicated thread, they should be wrapped in a fork-statement. The three available options for a fork-statement are:\n fork \u0026hellip; join runs all the statements in parallel. The first statement after the fork \u0026hellip; join (task d) will be executed when all parallel statements are finished. fork \u0026hellip; join_any runs all the statements in parallel. The first statement after the fork \u0026hellip; join_any (task d) will be executed when the first of the parallel statements is finished. fork \u0026hellip; join_none runs all the statements in parallel. The first statement after the fork \u0026hellip; join_none (task d) will be executed immediately after initiating the parallel statements.  Adding disable fork and wait fork to the mix, gives you a lot of control.\n disable fork; terminates all remaining forked blocks wait fork; causes calling process to block until all the sub-statements are completed.  The disable fork statement stops all active threads that were spawned from the current thread. The problem is that this may accidentally stop threads that you did not intended to. -- --  Back to the Environment With all that tackled, the environment can be fixed.\nWhen the run() method is called, 2 threads need to be started in parallel: 1 for the driver, and 1 for the monitor. This allows to run both instances in parallel.\nThe fork is closed with a join_any.\nAfter giving 10 clock cycles of spin-up, the downstream threads are started in a join_any. If you remember, the Monitor has a forever loop, so the this.mon.run() will never end. This implies that the fork is ended when the driver ends.\nTo illustrate this, the Transcript windows of both simulations (with and without fork) are shown below.\n class environment; virtual gbprocessor_iface ifc; driver drv; monitor mon; function new(virtual gbprocessor_iface ifc); this.drv = new(ifc); this.mon = new(ifc); endfunction : new task run(); fork this.drv.run_addition(); this.mon.run(); join_any; $display(\u0026#34;[ENV]: end of run()\u0026#34;); endtask : run endclass : environment  \n\nTake a close look at the timestamp of the message that stated the Monitor will start working.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/304_transactions/",
	"title": "304 Transactions",
	"tags": [],
	"description": "",
	"content": " Transactions Now we\u0026rsquo;re truly going OO with this testbench. Up until this point, 2 classes (that did something useful) were added : driver and monitor. Adding more classes for generators, checkers, \u0026hellip; should not be too much of a challenge, from a coding point-of-view.\nThe structure, however, should become clear by now:\n The generator generates a testvector This testvector is sent to the driver and the checker The driver translates the input to pin-wiggles    The monitor translates the output pin-wiggles to something readable. The monitor forwards its output to the checker The checker verifies the correctness The scoreboard is updated by the checker\u0026rsquo;s ruling   \nTransactions To use the testbench in a generic way to enhance reusability, it is important that the generated testvectors are described in a generic form. Well \u0026hellip; let\u0026rsquo;s use a class for that as well.\nclass transaction; byte instruction; function new(); this.instruction = 8\u0026#39;h8c; endfunction : new function string toString(); return $sformatf(\u0026#34;Instruction: %08x\u0026#34;, this.instruction); endfunction : toString endclass : transaction;  \nThis class describes the transaction. It has only a single property: instruction\nUpon construction, the value for this object\u0026rsquo;s instruction is fixed (for now) to 0x8C (aka ADC H`)\nThere is a function toString( ) that, as the name suggests, makes a sting from the object\u0026rsquo;s property values.\n\n\nMake sure you spot the return-value type string in the toString( ) method.\n Generator The generator is the object that will create the aforementioned transactions. While making an object this class nothing else happens (for now).\nFurthermore, it has a function run( ) which \u0026hellip; well \u0026hellip; generates a transaction and displays which instruction was generated. This is repeated for 10 times.\n `include \u0026#34;transaction.sv\u0026#34; class generator; function new; endfunction : new task run; transaction tra; for(int i=0; i\u0026lt;10; i++) begin tra = new(); $display(\u0026#34;%s\u0026#34;, tra.toString()); end endtask : run endclass : generator  \n\nTo glue everything together, a small test is set up which creates a generator and triggers it\u0026rsquo;s run( ) function. The result is shown below.\n`include \u0026#34;generator.sv\u0026#34; program test(); generator gen = new(); initial begin gen.run(); end endprogram : test  \n\n\nGreat !! Now you can generate all the testvectors that you want 😃 Only \u0026hellip; they are all the same and only live within the generator. Let\u0026rsquo;s fix that with mailing transactions around.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/305_mailboxes/",
	"title": "305 Mailboxes",
	"tags": [],
	"description": "",
	"content": " Mailboxes Up until this point the layered testbench was presented: there are different layers each with their own purpose. Also: transactions were shortly discussed. Next up \u0026hellip; handing out transactions between different layers.\nMailbox is a built-in class. It works similar to an actual (single direction) mailbox. It\u0026rsquo;s worth pointing out that a mailbox operates like a FIFO (whereas an actual mailbox might operate as a LIFO (?)) and it has the following methods:\n new( ): create a new mailbox put( ): put a message in the mailbox get( ): get a message from the mailbox peek( ): copy a message from the mailbox num( ): retrieve the number of messages in the mailbox   Except for the new( ) and num( ) function, all of these methods are blocking functions. This means, upon running the get() function, the software keeps on getting a message, until it succeeds.\nAs this might not always be desirable, there also exist these non-blocking alternatives:\n try_put( ): put a message in the mailbox try_get( ): get a message from the mailbox try_peek( ): copy a message from the mailbox   \nTry to think of a reason why put, get and peek would block !\n Mailboxes accept any type of variable or object, by default. You can (and should) make them type specific with parametrisation.\nThis creates a mailbox with room for 10 entries of any type. mailbox bigRedShinyBox = new(10); \n This creates a mailbox with room for 10 variables of int type. mailbox #(int) bigBlueShinyBox = new(10); \n \nFor the sake of completeness it is mentioned that SystemVerilog has another built-in class that allows inter-process communication: Semaphores. This will not be handled in these labs, but more information on semaphores can be found here or on Google .\nLet\u0026rsquo;s see it in action As with many things, hands-on experience helps understanding certain principles. Let\u0026rsquo;s see the mailbox in action. The testbench was left with a generator generating 10 transactions. Here, we\u0026rsquo;re adding a mailbox, so the generator can mail the transactions to the driver.\n`include \u0026#34;transaction.sv\u0026#34; class generator; mailbox #(transaction) gen2drv; function new(mailbox #(transaction) g2d); this.gen2drv = g2d; endfunction : new task run; string s; transaction tra; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); s = $sformatf(\u0026#34;[%t | GEN] I will start generating for the mailbox\u0026#34;, $time); $display(s); for(int i=0; i\u0026lt;10; i++) begin tra = new(); s = $sformatf(\u0026#34;[%t | GEN] new instruction %s\u0026#34;, $time, tra.toString()); $display(s); this.gen2drv.put(tra); end endtask : run endclass : generator  \nThis example shows how the generator uses a mailbox.\nFirst, there is a class property gen2drv. Upon making an instantiation of the class generator, the constructor assigns the property to a mailbox-object. Note that this mailbox only accepts object\u0026rsquo;s of the type transaction.\nWhenever the run function is executed and the generator is working its magic, the resulting transaction is put into the objects mailbox.\nAnd \u0026hellip; that\u0026rsquo;s it 😃\n\n\nTry to think of a reason why the variable tra can be reused? Wouldn\u0026rsquo;t the next iteration of the for-loop overwrite the values of the previously generated transaction?\n This example shows how the driver uses the mailbox.\nSimilarly to the generator, first, there is a class property gen2drv. Upon making an instantiation, the constructor assigns the property to a mailbox-object.\nNote that the name is independent, but the same. The philosophy behind is: first give the name of the sender, followed by a \u0026ldquo;2\u0026rdquo;, appended with the name of the destination.\n In the run_addition( ) function, the driver will wait for a transaction. Once this has arrived, it waits for a falling edge of the clock. Finally it drives the new inputs as they appear in the transaction.\nAnd \u0026hellip; that\u0026rsquo;s it 😃\n\nclass driver; virtual gbprocessor_iface ifc; mailbox #(transaction) gen2drv; function new(virtual gbprocessor_iface ifc, mailbox #(transaction) g2d); this.ifc = ifc; this.gen2drv = g2d; endfunction : new task run_addition(); string s; transaction tra; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); s = $sformatf(\u0026#34;[%t | DRV] I will start driving from the mailbox\u0026#34;, $time); $display(s); forever begin this.ifc.valid \u0026lt;= 1\u0026#39;b0; this.gen2drv.get(tra); @(posedge this.ifc.clock); this.ifc.valid \u0026lt;= 1\u0026#39;b1; this.ifc.instruction \u0026lt;= 8\u0026#39;h82; end /* forever */ s = $sformatf(\u0026#34;[%t | DRV] done\u0026#34;, $time); $display(s); endtask : run_addition endclass : driver  \n\nWhere only a couple of pages back, the driver was concerning itself with the actual values, it no longer has that responsibility. It simply executes what it is instructed to, by mail.\nNow we have generation and handling of mail, but \u0026hellip; how did the mailbox come into existence ? Right \u0026hellip; that should be done one abstraction level higher: in the environment.\n`include \u0026#34;transaction.sv\u0026#34; `include \u0026#34;generator.sv\u0026#34; `include \u0026#34;driver.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; class environment; mailbox #(transaction) gen2drv; virtual gbprocessor_iface ifc; generator gen; driver drv; monitor mon; function new(virtual gbprocessor_iface ifc); this.ifc = ifc; this.gen2drv = new(5); this.gen = new(this.gen2drv); this.drv = new(ifc, this.gen2drv); this.mon = new(ifc); endfunction : new task run(); string s; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); s = $sformatf(\u0026#34;[%t | ENV] I will set up the components\u0026#34;, $time); $display(s); this.drv.do_reset(); fork this.drv.run_addition(); this.mon.run(); this.gen.run(); join_any; s = $sformatf(\u0026#34;[%t | ENV] end of run()\u0026#34;, $time); $display(s); endtask : run endclass : environment  \nAs you can already see from the number of lines, some elaboration would be welcome.\nFirst, the environment class has a class property: gen2drv. Its type is a parametrised mailbox.\nNext to the driver and monitor properties, there is also a generator property.\nUpon creation of an environment, the mailbox-class is instantiated. The parameter 5 that is given determines the size (depth) of the mailbox.\n Apart from creating the mailbox and attaching both ends to the correct components, the generator also has to be triggered. As the driver now also has a forever-loop, it can be started together with the monitor, in parallel.\nAfter running for 10 clock cycles the run( ) function of the generator is triggered.\nWhen the generator has finished, everything in the outer fork-join will be disabled and the test is done.\n\n\nQuick questions:\n how many testvectors were generated ? are all testvectors generated at the same moment ? Explain why !! which component/object is the one that determines how long the test takes ?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/306_assignment/",
	"title": "306 Assignment 2",
	"tags": [],
	"description": "",
	"content": " Assignment 2 The second assignment is to build your first layered testbench. The DUT, again, is the ALU with the register file that was seen earlier. The test is assumed to be done when the scoreboard has received 100 test results, irrespective whether or not the results were correct. When this is amount of tests is reached, the scoreboard should print a summary of the obtained results.\nA number of small remarks:\n The generator can (for now) simply generate the same instruction over and over; All the default components should be present (generator, driver, monitor, checker, scoreboard) in the environment; The output should look (something) like the image below.  After this chapter you should \u0026hellip;  ... have gotten your hands dirty   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/307_scoreboard/",
	"title": "307 Checker &amp; scoreboard",
	"tags": [],
	"description": "",
	"content": " A number of steps on the OO-ladder have already been taken. First of all, there is the interface that does all the pin-interconnecting. One layer above there are the driver and the monitor. These two components translate between the software world and the hardware world.\nThe driver is instructed by the generator, through the use of transactions. In this final section the path will be completed.\nFirst, there is the checker, that verifies the result as seen by the monitor against a golden value.\nAnd, finally, there is a scoreboard that collects all the results.\nNeither of these components will introduce new concepts, but for the sake of completeness they are discussed here. However, coming up with the golden reference will require some more work.\nIt is pointed out that there is no precise separation of tasks to certain components. In general it is clear what each compent does, but the exact borders between tasks are not set in stone. What is taught here is a default approach.\n -- Checker `include \u0026#34;transaction.sv\u0026#34; class checkers; mailbox #(transaction) gen2che; mailbox #(shortint) mon2che; mailbox #(bit) che2scb; function new(mailbox #(shortint) m2c, mailbox #(bit) c2s); this.mon2che = m2c; this.che2scb = c2s; endfunction : new task run; shortint expected_result, received_result; string s; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); s = $sformatf(\u0026#34;[%t | CHE] I will start checking\u0026#34;, $time); $display(s); forever begin this.mon2che.get(received_result); /* do something to get the. For now, have this placeholder */ received_result = expected_result; if (received_result == expected_result) begin this.che2scb.put(bit\u0026#39;(1)); end else begin this.che2scb.put(bit\u0026#39;(0)); end end endtask endclass : checkers  \nThe checker uses multiple mailboxes. There is one incoming communication channel from the generator. This will be required to be able to determine the golden value; there is another incoming channel from the monitor for providing the obtained result, and finally, there is one outgoing channel to the scoreboard (for keeping score).\nPlease note that checker is a keyword in SystemVerilog. Hence, the name of the class is checkers.\n When the expected outcome, or golden value is determined, the checker compares whether or not this value matches with obtained result. In the example, there is simply a placeholder.\nIts decision is then sent to the scoreboard. Note the type to which the che2scb mailbox is fixed.\n\n\nScoreboard An example of a scoreboard is given here. There should be nothing out-of-the-usual here.\nOne point that is worth mentioning is the conclusion that all blocks up-until-this-point are running forever. (Or they will be if you look at the entire code for this example 😉)\nA closer look at the scoreboard shows that this run( ) function only runs for a certain amount of test vectors.\n class scoreboard; mailbox #(bit) che2scb; int NO_tests; int no_tests_done; int no_tests_ok; int no_tests_nok; function new(mailbox c2s); this.che2scb = c2s; NO_tests = 0; no_tests_done = 0; no_tests_ok = 0; no_tests_nok = 0; endfunction : new task run(int NOT); byte result; string s; this.NO_tests = NOT; $timeformat(-9,0,\u0026#34; ns\u0026#34; , 10); s = $sformatf(\u0026#34;[%t | SCB] I will start keeping score\u0026#34;, $time); $display(s); while (this.no_tests_done \u0026lt; this.NO_tests) begin this.che2scb.get(result); no_tests_done++; if (result \u0026gt; 0) begin no_tests_ok++; //$display(\u0026#34;[SCB] successful test registered\u0026#34;);  end else begin no_tests_nok++; //$display(\u0026#34;[SCB] unsuccessful test registered\u0026#34;);  end end /* while*/ endtask : run task showReport; $display(\u0026#34;[SCB] Test report\u0026#34;); $display(\u0026#34;[SCB] ------------\u0026#34;); $display(\u0026#34;[SCB] # tests done : %0d\u0026#34;, this.no_tests_done); $display(\u0026#34;[SCB] # tests ok : %0d\u0026#34;, this.no_tests_ok); $display(\u0026#34;[SCB] # tests failed : %0d\u0026#34;, this.no_tests_nok); $display(\u0026#34;[SCB] # tests success rate : %0.2f\u0026#34;, this.no_tests_ok/this.no_tests_done*100); endtask : showReport endclass : scoreboard  \n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/300_oo/308_golden/",
	"title": "308 Golden reference",
	"tags": [],
	"description": "",
	"content": " Golden reference In larger design houses there is a strict separation between the designers and verifiers. Both are given a \u0026lsquo;requirements document\u0026rsquo; and are not allowed to talk to each other. This is for the simple reason that having two independent interpretations might point out errors in each others\u0026rsquo;s interpretation (or in the \u0026lsquo;requirements document\u0026rsquo;).\nA well-tested technique to obtain the right answer from a model. The stimuli, that are given to the DUT are also given to the model. The outcome of the DUT is then compared to that of the model. In an ideal scenario, both answers should always match.\nAs we have an OO-environment, it only makes sense to write the model in the same language.\nThe example below shows how the model could be developed.\n/* A new class is made for the model :) */ class gameboyprocessor; /* Eight 8-bit registers */ byte A; byte B; byte C; byte D; byte E; byte F; byte H; byte L; /* Upon creating an object, the registers are initialised. A simplication was done, because the LOAD instructions are not implemented. Hence, all values are constant (except for those of A and F).*/ function new(); this.A = 0; this.B = 1; this.C = 2; this.D = 3; this.E = 4; this.F = 0; this.H = 5; this.L = 6; endfunction : new /* A simple to string function to consult the internals. */ task toString(); $display(\u0026#34;REG A : %02X \\t\\tREG F : %02X\u0026#34;, this.A, this.F); $display(\u0026#34;REG B : %02X \\t\\tREG C : %02X\u0026#34;, this.B, this.C); $display(\u0026#34;REG D : %02X \\t\\tREG E : %02X\u0026#34;, this.D, this.E); $display(\u0026#34;REG H : %02X \\t\\tREG L : %02X\u0026#34;, this.H, this.L); endtask : toString /* Here is the bread-and-butter of the model. Similar to the DUT, an instruction can be fed to the model. The model performs the same operation on its internal registers as the DUT. */ task executeALUInstruction(byte instr); /******** content should go here ********/ endtask : executeALUInstruction endclass : gameboyprocessor /* A small program to test the model */ program test_cpumodel; static gameboyprocessor gbmodel; initial begin /* instantiate model */ gbmodel = new(); /* show the initial values of the register file*/ gbmodel.toString(); /* ADC H =\u0026gt; A = A + H + Cin =\u0026gt; 0 + 5 + 0 = 5 = 0x5*/ $display(\u0026#34;Executing instruction 0x8C\u0026#34;); gbmodel.executeALUInstruction(8\u0026#39;h8C); /* show the final values of the register file*/ gbmodel.toString(); $display(\u0026#34;Executing instruction 0x8C\u0026#34;); gbmodel.executeALUInstruction(8\u0026#39;h8C); gbmodel.toString(); $display(\u0026#34;Executing instruction 0x8C\u0026#34;); gbmodel.executeALUInstruction(8\u0026#39;h8C); gbmodel.toString(); $display(\u0026#34;Executing instruction 0x8C\u0026#34;); gbmodel.executeALUInstruction(8\u0026#39;h8C); gbmodel.toString(); end endprogram : test_cpumodel  \nThe gameboyprocessor model has 8 properties that represent the 8 registers in the registerfile. Upon making an object, these registers are initialised to the same values as the hardware.\nNext, there is a toString() function that simply prints the values of all the modelled registers.\nIn this simple model of this simplified processor, the task that will do the heavy lifting is executeALUInstruction(). Note that this is a task and not a function.\n Below the model, there is a small program which can be used to test the model. It simply makes an object of the class gameboyprocessor. It executes the ADC H instruction. The internal values of the registers are shown before and after the instruction.\nThe output of the program looks like shown below.\nThe result of REG A shows the expected outcome.\nRunning the same instruction 3 more times, should end up with the register A containing the value 20 (0x14). In the fourth instruction there is an overflow of the lower to the higher nibble (register A goes from 0x0F to 0x14). This is reflected in register F (bit-index 1).\n\n\nExecise Try to complete the executeALUInstruction(byte instr) function so an ADD H instruction can be execute in your model.\n the expected outcome is the sum of the contents of register H and register A the expected outcome is stored in register A Zero flag, F(3), is set if the result is 0x0 Subtract flag, F(2), is cleared Half Carry flag F(1) is only set if a carry occurred from the lower to higher nibble Carry flag, F(0), is only set if an overflow occurs  After this chapter you should \u0026hellip;  ... have a clear idea what is meant with a layered testbench ... see how object-oriented programming is mixed with RTL design ... understand terms like **generator** and **scoreboard** and understand there function   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/400_rand/",
	"title": "4 Randomisation",
	"tags": [],
	"description": "",
	"content": " Randomisation Image courtesy: Pexels - Aidan Howe   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/400_rand/401_randomisation/",
	"title": "401 Randomisation",
	"tags": [],
	"description": "",
	"content": " Randomisation From the classical approach of testbenches, you already know that you best test your design with different values.\nIn the previous part, we validated that 0 + 5 equals 5. Although repeating a test with same value could learn something, after a few correct iterations, however, it can be determined that the design knows how to handle that instruction.\nIn this part the instruction needs to be randomised. When working within a class declaration, making a data member randomisable is very straightforward by using the keywords rand or randc.\nrand Using the rand keyword, labels a member to be randomisable. class demo rand bit[1:0] data \u0026hellip; \nE.g. the outcome could be: 2\u0026rsquo;b01, 2\u0026rsquo;b11, 2\u0026rsquo;b00, 2\u0026rsquo;b01, 2\u0026rsquo;b10, \u0026hellip; \n randc Similarly, using the randc keyword also labels a member to be randomisable. The additional requirement in randc is that it loops through all possible numbers prior to starting over. class demo randc bit[3:0] data \u0026hellip; \nE.g. the outcome could be: 2\u0026rsquo;b10, 2\u0026rsquo;b11, 2\u0026rsquo;b01, 2\u0026rsquo;b00, 2\u0026rsquo;b01, \u0026hellip; \n \nThe modifications to the code are, as you can see below, minimal. The rand (or randc) keyword can only be applied in a class declaration.\n`ifndef SV_TRA_TRANSACTION `define SV_TRA_TRANSACTION  class transaction; byte instruction; ...  \n`ifndef SV_TRA_TRANSACTION `define SV_TRA_TRANSACTION  class transaction; rand byte instruction; ...  \n\nHow to randomise Above, the SystemVerilog approach to marking a member as randomisable is explained. This doesn\u0026rsquo;t assign a random value to the class members, mind you. Once an object is created, SystemVerilog allows to call the randomize() method that assigns random values to the class members that are marked with rand or randc.\nAlthough you don\u0026rsquo;t have to write/program this method, every class has a built-in randomize() virtual method. The signature of this method is:\n virtual function int randomize();\n The virtual function returns an int: 1 for success, and 0 otherwise. The code below illustrates how to get a randomised transaction. Convince yourself that this is not complicated, but may be a bit cumbersome to write. A shorter way of randomising is ignoring the return value of the function. To achieve this, the return value is typecast to void.\n... /* create an object */ transaction myTrans; /* call the virtual method randomise */ if(myTrans.randomize()) $display (\u0026#34;myTrans has been randomised\u0026#34;) else $display (\u0026#34;myTrans has NOT been randomised\u0026#34;) /* a shorter way */ void\u0026#39;(myTrans.randomize()); ...  Enable/disable randomisation SystemVerilog objects have a function rand_mode() that can enable or disable the effect of randomisation. With some scenarios it can be useful to be able to turn off randomisation. When randomisation is disabled, these class properties act as normal variables. Initially, all class properties that have the rand or randc keywords have randomisation enabled. The rand_mode() method is a built-in task that cannot be overwritten. For the sake of completeness it is mentioned that the rand_mode() function can also be used to check whether the randomisation is enabled or not, by simply evaluating the return value.\nWith the example of the transactions, this can be achieved as follows:\ntransaction myTrans; /* disable ALL random class properties */ myTrans.rand_mode(0); /* enable ALL random class properties */ myTrans.rand_mode(1); /* disable only the random class properties: operation */ myTrans.operation.rand_mode(0); /* check the mode*/ if myTrans.operation.rand_mode() $display(\u0026#34;Randomisation of \u0026#39;operation\u0026#39; is enabled\u0026#34;); else $display(\u0026#34;Randomisation of \u0026#39;operation\u0026#39; is disabled\u0026#34;);  Seeding As you may notice, during some tests, SystemVerilog always generates the \u0026ldquo;same\u0026rdquo; sequence of random numbers. Therefore, you might think \u0026ldquo;Well, that\u0026rsquo;s not random then.\u0026rdquo;\nHowever, this is a very nice feature. When you write more complex test scenarios it might happen that at a certain point in time an error pops up. If the random generation were truly random, you had no means of rerunning the same tests with the same numbers. 😃\nIf you want to test with different series of random numbers, you can re-seed the random number generator. This can be achieved by setting the seed in the constructor of an object with srandom (seed); where seed is a different number.\nRunning with a seed x generates one certain stream of random numbers for that object, while running with seed y provides you with another. If your test reports show that there was an issue in the x series, you can go and investigate this later.\nExercise As mentioned before, SystemVerilog uses a lot of different files. Sometimes, certainly when learning the language, it can be useful to test a smaller portion on its own.\nTake, for example, the transaction class. In SystemVerilog it is perfectly OK to add program in the same file.\n A program can be used similarly to a module. While the latter is used for RTL code, a program is used for verification. The difference lies with how the scheduler of the simulator handles the program or module. This, however, falls out of scope for this introductory course.\n class random_example; rand byte something; rand byte another_thing; function new(); this.something = 0; this.another_thing = 0; endfunction : new function string toString(); return $sformatf(\u0026#34;Something is %02x and another thing is %02x\u0026#34;, this.something, this.another_thing); endfunction : toString task printString(); $display(this.toString()); endtask : printString endclass : random_example program test_random_example(); random_example re; initial begin re = new(); for(int i=0;i\u0026lt;20;i++) re.printString(); for(int i=0;i\u0026lt;20;i++) begin void\u0026#39;(re.randomize()); re.printString(); end end endprogram : test_random_example  To run this test on the transaction, QuestaSim can be used \u0026hellip; even without a GUI.\nThe commands that were used:  vsim -c vlog -sv randomisation.sv vsim -voptargs=\"+acc\" test_random_example run 2 us   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/400_rand/402_constraint/",
	"title": "402 Constraints",
	"tags": [],
	"description": "",
	"content": " Constraints Time for another Buzz-word lightning round: SystemVerilog supports Constrained Random Verification. If you simply breakdown the words, it becomes quite clear already. Verification should be clear. Random, after the previous section, should also ring a bell. Then there is the third word: Constrained.\nGenerating random numbers to apply as stimuli is useful. It helps the verification engineer to touch on corner cases that might be missed while trying come up with all test vectors himself/herself. Hooray for randomness.\nTo be more in control of which random numbers are generated, it is useful to be able to lay constraints on the random number generator. These constraints can be altered during the tests or between different test scenarios.\nclass OperandsDemo; rand byte A; rand byte B; constraint c1 { A[3:0] == 4\u0026#39;b0; } function string ToString(); return $sformatf(\u0026#34;A: %08b, B: %08b\u0026#34;, this.A, this.B); endfunction : ToString endclass : OperandsDemo; program test; static OperandsDemo demo; initial begin for(int i=0;i\u0026lt;10;i++) begin demo = new(); void\u0026#39;(demo.randomize()); $display(\u0026#34;%s\u0026#34;, demo.ToString()); end end endprogram : test  \nIn this example, the class OperandsDemo shows how to put a constraint on operand A. A few remarks:\n the keyword constraint is used, before a human name of the constraint the lines that define the constraint must be ended with a semicolon the definition of the constraint looks like a test. Something you could write in an if( ) statement. a constraint can only be declared in a class  When an object is being randomised, the constraints are checked. If the constraints hold, the simulator continues. If the constraints are violated, new values are generated until the constraints are met.\nTo be complete, there are a number of other requirements:\n the constraint should be of integral type (bit, int, logic, reg, \u0026hellip;) constraints only support 2-state values by default, constraints are enabled, but they can disabled   \nIt is fairly clear what the constraint in the example will accomplish. The 4 least significant bits of A should be zero. The result of the example is shown below.\n$ vsim -c $ vlog -sv OperandsDemo.sv $ vsim -voptargs=\u0026#34;+acc\u0026#34; test $ run 10 us \n \nAnother example Another intuitive example is given.\n... constraint c1 { A[3:0] == 4\u0026#39;b0; } constraint c2 { B \u0026gt; A; } ...  \n# A: 00100000, B: 01011111 # A: 10110000, B: 01011000 # A: 10010000, B: 10100001 # A: 01000000, B: 01110011 # A: 10010000, B: 11101010 # A: 10010000, B: 00000100 # A: 11010000, B: 00000110 # A: 10010000, B: 10101101 # A: 00100000, B: 00110111 # A: 00010000, B: 00101000 \n\nExercise Have a look at the second line of the generated values. Did you expect this ?Try to fix it !!  SystemVerilog assumes that A and B are signed. Therefore, values with the most significant bit at '1' are negative. Fixing the constraint can be done with: unsigned'(B)  unsigned'(A);   A few more general remarks on constraints:\n constraints should be of integral type (bit, reg, logic, integer, \u0026hellip;) constraints support only 2-state values. Values or operators (e.g. ===, !==) on 4-state values are not illegal. Beware that you can still use a value of the type logic (4-state), as long as it only contains 0\u0026rsquo;s and/or 1\u0026rsquo;s. constraints can be inherited from parent classes constraints can use a function. This could come in handy if the desired properties are too complex to express in a single expression.  class SomethingFancy; rand integer value; constraint c1; endclass : SomethingFancy constraint SomethingFancy::c1 { value \u0026lt; 1000; }  \nclass SomethingFancy; rand integer value; constraint c1; endclass : SomethingFancy class SomethingFancier extends SomethingFancy; constraint c1 {value \u0026gt; 0;} endclass : SomethingFancier  \n\nfunction byte increment( byte x ) return x+1; endfunction : increment class OperandsDemo; rand byte A; rand byte B; constraint c1 { B == increment(A) } constraint c2 { A[3:0] == 4\u0026#39;b0; } endclass : OperandsDemo  Constraint ordering With these two examples c1 and c2 not many issues could arise. However, when the complete testbench becomes much larger and more complex, generating random values that fulfil the constraints can become processor intensive. SystemVerilog allows the verification engineer to help, by determining the order in which the constraints should be tackled.\n constraint c1 { A[3:0] == 4\u0026#39;b0; } constraint c2 { unsigned\u0026#39;(B) \u0026gt; unsigned\u0026#39;(A); } constraint c3 { solve A before B; }  \n\nEnable/disable constraints Similar to enabling and disabling randomisation, constraints can be enabled and disabled as well. This is done through demo.c2.constraint_mode(0) or demo.c1.constraint_mode(1) to respectively disable c2 or enable c1;\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/400_rand/403_dpandcp/",
	"title": "403 DP and CP",
	"tags": [],
	"description": "",
	"content": " DP and CP A natural tendency you might have (I know I have) is to start applying different test vectors: \u0026ldquo;Ok, my design knows 20 + 30, but does it also know 21 + 30 ?\u0026rdquo;\nRandomising the inputs is a logical next step. Although this step is useful, it\u0026rsquo;s far from sufficient.\nYears ago in this study program you were introduced to hardware design. Here you learned about the datapath (DP) and the control path (CP). The datapath is the part of your design that handles the actual data. In the example of our processor, this simply covered the instruction and the probed output of reg A. The control path is the part of your design that directs your datapath to behave correctly. In the example of our ALU, this covers: the input flags, the operation and the output flags.\nIt has been shown in the earlier sections of this chapter how randomisation can help us to better test a design. However, the only part that was randomised was the data path. A bold tester might even say after 10 successful tests of each operation of the ALU that the ALU works fine. (FTR: I\u0026rsquo;m not that bold 😃)\nWhat if the control path would (also) be randomised ?\nImagine the following bug:\n If an ADD is done after a SBC, an incorrect N-flag is reported.\n Because the course handles a simplified processor as DUT, this scenario might be a bit far fetched. Let\u0026rsquo;s assume, nevertheless, that such a bug is there. Would your normal testbench catch it ? Or \u0026hellip; would the SystemVerilog code (as it is at this point) catch it ?\nExercise: Taking apart the instruction The input to the DUT now simply is 1 single byte. However, these 8 bits are a concatenation of 3 different parameters:\n the first two bits (roughly) signal when the ALU is targeted. This can be deduced from the instruction set (e.g. here): when the instruction starts with \u0026ldquo;10\u0026rdquo;, the ALU is required; the next three bits indicate which operation is selected (see 201); the final three bits indicate the selected operand.  There is no rule that dictates that the instruction property in the transactions class must reflect the interface of the DUT.\nclass transaction; rand byte instruction;  \nclass transaction; rand bit [1:0] instruction_type; rand bit [2:0] instruction_selection; rand bit [2:0] operand_selection; \n\n\nThis, of course, has some minor implications on the rest of the class.\nclass transaction; rand bit [1:0] instruction_type; rand bit [2:0] instruction_selection; rand bit [2:0] operand_selection; function new(); this.instruction_type = 2\u0026#39;h0; this.instruction_selection = 3\u0026#39;h0; this.operand_selection = 3\u0026#39;h0; endfunction : new function string toString(); return $sformatf(\u0026#34;Instruction: %02x %02x %02x (%02x) \u0026#34;, this.instruction_type, this.instruction_selection, this.operand_selection, this.toByte); endfunction : toString function byte toByte(); return byte\u0026#39;(this.instruction_type * 2**(6) + this.instruction_selection * 2**(3) + this.operand_selection); endfunction : toByte; endclass : transaction;  In the example above the toString() method has be updated to the new properties. Additionally, a toByte() function is added. This method will useful in the driver.\nthis.ifc.instruction \u0026lt;= tra.instruction; /* will become */ this.ifc.instruction \u0026lt;= tra.instruction.toByte();  More constraints Two more ways to constraint the randomness generation are given here.\ninside and dist Two keywords can help you in verifying the design: inside and dist. Two examples are given below. Pay attention to the syntax !! Brackets, semicolons, curly brackets, etc. it sometimes becomes delicate.\ninside With the inside keyword a value can be forced to lay between two different values. constraint c1 { (instruction_selection inside {3\u0026#39;b000, 3\u0026#39;b001}); } constraint c2 { (instruction_selection inside {[0:3]}); } constraint c3 { !(instruction_selection inside {[0:3]}); } \nThe c1 constraint implies that the operation must be either ADD or ADC. The possible values of instruction_selection are enumerated between the curly brackets.\nThe c2 constraint implies that the operation must be an arithmetic operation. The possible values of operation lies within the range 3'b000 to 3'b011 (with the upper-limit inclusive).\nThe c3 constraint implies that the operation may not be an arithmetic operation. The possible values of operation may not lay within the range 3'b000 to 3'b011.\n dist With the dist keyword a value can be given a distribution of occurring. constraint c1 { instruction_selection dist { 0 := 1, 1 := 5, 2 := 1, 3 := 5 }; } constraint c2 { instruction_selection dist { [0:3] := 5, [4:7] := 1 }; } constraint c3 { instruction_selection dist { [0:3] := 5, [4:7] :/ 1 }; } \nThe c1 constraint implies that the operation must be an arithmetic operation (because only values 0, 1, 2, and 3 are enumerated). On average, operations ADC and SBC should occur 5 times more than ADD and SUB.\nWith x := y the relative weight of generating value x is set to y.\nThe c2 constraint implies that an arithmetic operation occurs 5 times more than a logical operation.\nThe c3 constraint implies that the weight of 1 is assigned to the entire range. This boils down to values 4-7 having a weight of 0.25, each.\n \n Implication Through the use of the implication-operator (-\u0026gt;) conditional relations can be installed.\nclass OperandsDemo; rand byte A; rand byte B; constraint c_implication_example { A == 0 -\u0026gt; B \u0026lt; 12; A == 1 -\u0026gt; B \u0026gt; 11; }  It is pointed out that these restrictions might seem a bit far fetched for this simple example.  Hopefully these constraints give you a hint of the power of constraining randomness. By enabling/disabling such constraints the verification engineer can tune his/her test scenario to verify specific goals.   Also note that these keywords can also be used for constraining the randomness in the datapath.\n There are even more techniques to control the randomness generation. Also, given the object-oriented nature of SystemVerilog a lot more can be achieved by making subclasses an inheriting randomness settings and constraints from the parent classes. Handling all these degrees of freedom, however, would take us too far in this course.\nA small example on class inheritance is given below.\nclass transaction; rand bit [1:0] instruction_type; rand bit [2:0] instruction_selection; rand bit [2:0] operand_selection; function new(); this.instruction_type = 2\u0026#39;h0; this.instruction_selection = 3\u0026#39;h0; this.operand_selection = 3\u0026#39;h0; endfunction : new function string toString(); return $sformatf(\u0026#34;Instruction: %02x %02x %02x (%02x) \u0026#34;, this.instruction_type, this.instruction_selection, this.operand_selection, this.toByte); endfunction : toString function byte toByte(); return byte\u0026#39;(this.instruction_type * 2**(6) + this.instruction_selection * 2**(3) + this.operand_selection); endfunction : toByte; endclass : transaction;  \nclass ALUtransaction extends transaction;\nfunction new(); super.new(); this.instruction_type.rand_mode(0); this.instruction_type = 2\u0026#39;h2; endfunction : new\nendclass : ALUtransaction; \n\n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/400_rand/404_assignment/",
	"title": "404 Assignment 3",
	"tags": [],
	"description": "",
	"content": " Assignment 3 The third assignment focuses on the Transaction-class, but effects most components on the functional layer. As a reminder, objects of the transaction class are generated in the generator and are sent to the Driver and the Checker. The class must have the class members as stated below. The new and ToString methods should remain unmodified.\nclass transaction; rand bit [1:0] instruction_type; rand bit [2:0] instruction_selection; rand bit [2:0] operand_selection; function new(); this.instruction_type = 2\u0026#39;h0; this.instruction_selection = 3\u0026#39;h0; this.operand_selection = 3\u0026#39;h0; endfunction : new function string toString(); return $sformatf(\u0026#34;Instruction: %02x %02x %02x (%02x) \u0026#34;, this.instruction_type, this.instruction_selection, this.operand_selection, this.toByte); endfunction : toString function byte toByte(); return byte\u0026#39;(this.instruction_type * 2**(6-1) + this.instruction_selection * 2**(3-1) + this.operand_selection); endfunction : toByte; endclass : transaction program assignment3(); transaction tra; initial begin /* COMPLETE THIS CODE */ end endprogram : assignment3  For this assignment the program assignment3 should generate:\n Test 1: 100 tests random operands for each operation (ADD, ADC, SUB, SBC, AND, XOR, OR, CP) specifically (totalling on 800 tests) Test 2: 100 tests with random operands for operations that start with an A (ADD, ADC or AND) Test 3: 100 tests with random operands and random operations. After a SUB operation, the next operation MUST be XOR Test 4: 1\u0026rsquo;000 tests with random operands. Roughly 20% of the tests should be the CP operation. Print a summary of these tests to show the constrained is met.  Note that:\n a random operand implies: one of the 8 registers you can ADD everything you want to the transaction class below are some example screenshots of the expected results of the 4 tests      \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/",
	"title": "5 Coverage",
	"tags": [],
	"description": "",
	"content": " Coverage Image courtesy: Pexels - Vladislav Vasnetsov   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/501_coverage/",
	"title": "501 Coverage",
	"tags": [],
	"description": "",
	"content": " Coverage By now, hopefully, you are starting to see the potential of SystemVerilog. Up until this point a lot of concepts were introduced and code has already been written, but take a look at the amount of tests that were done. In the final assignment a total of 2\u0026rsquo;000 different testvectors were applied to the DUT.\nA question that now might arise is: How much verification is enough ?\nTo address this question, the next topic in these labs is coverage. There are two types of coverage in SystemVerilog:\n Code coverage Functional coverage  Code coverage is simple, in contrast to functional verification, which is extremely complex and requires a lorry-load of experience.\nCode coverage Code coverage is done automatically by the simulator. However, by default it is disabled. The purpose of code coverage is to check whether or not every line of the code is reached.\nTo enable the use of code coverage, an additional argument has to be given to the compiler. For example:\nIndicate, during compilation, that coverage statistics are needed.\n vlog -sv ALU_iface.sv -cover bcestf\n  b collect branch statistics c collect condition statistics e collect expression statistics s collect statement statistics t collect toggle statistics f collect toggle statistics   Indicate, during simulation, that that coverage statistics is needed.\n vsim -voptargs=\u0026ldquo;+acc\u0026rdquo; -coverage top\n  \nWith these additional arguments set, the simulation has to be ran again. Finally, the simulator should have some means of displaying the code coverage. In case of QuestaSim, this is done by changing the Layout to Coverage.\nThis should result in something like is shown below.\nCode coverage can be useful but it is merely a tool to assist the verification engineer. Having complete code coverage doesn\u0026rsquo;t say anything on the functional verification of the design.\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/502_funccoverage/",
	"title": "502 Functional coverage",
	"tags": [],
	"description": "",
	"content": " Functional coverage SystemVerilog has two types of functional coverage. One type is data-oriented and falls within Covergroups. The other type is control-oriented and falls within Assertions. This chapter handles covergroups and the next chapter handles Assertions.\nCovergroups Covergroups can exists out of multiple coverpoints. A coverpoint is a specification of an expression. That doesn\u0026rsquo;t sound very clear, so let\u0026rsquo;s try to illustrate this with an example.\nIn our earlier example the operation property is a bit vector with a width of 5. A number of exercises were done in which we set a required number of tests on one specific operation. So actually we kept a score on every instruction by adding a mark every time a certain instruction was spotted.\nIn contrast to consciously keeping score per instruction, this can be done through a coverpoint.\n`include \u0026#34;gbprocessor_iface.sv\u0026#34; `include \u0026#34;test.sv\u0026#34; module top; logic clock=0; // clock generation - 100 MHz  always #5 clock = ~clock; // instantiate an interface  gbprocessor_iface gb_iface ( .clock(clock) ); // instantiate the DUT and connect it to the interface  gbprocessor dut ( .reset(gb_iface.reset), .clock(clock), .instruction(gb_iface.instruction), .valid(gb_iface.valid), .probe(gb_iface.probe) ); // SV testing  test tst(gb_iface); // cg1 defines a covergroup and is sampled at rising edge  covergroup cg1 @(posedge clock); c1: coverpoint gb_iface.instruction; endgroup // make an instance of cg1  initial begin cg1 cg1_inst; cg1_inst = new(); end endmodule : top  \nThe example shows the addition of a coverpoint and covergroup in the top module on the instruction signal.\nOn the top level a covergroup cg1 is defined. It is sampled/evaluated on the rising edge of the clock.\nWhen the top module starts running, an instance is made of the covergroup. From this moment on, the simulator will keep a tally on the instruction bus.\n \nNow, with the coverpoint in place, the simulator keeps track of which instructions are used. The image below shows how the Covergroups are visualised in QuestaSim. It can be seen that a number of bins are created e.g. bin auto[0:3]. This bin tallies the number of times the instruction is 0, 1, 2 or 3. The name of the bin is set to auto and the count is (at the moment of the screenshot) 0, while the next bin [4:7] has been hit 2 times.\nFinally, the simulator also calculates whether the intended goal is reached or not and gives an indication on the progress. Every bin in the coverpoint has a goal of 1, meaning that a single hit in a bin marks this bin as goal reached. If a bin is hit more than the intended value, the percentage stays at 100%.\nManipulating the bins Off course these bins can be manipulated, both in name an number. This code shows another covergroup that manipulates these bins. Rather than having 64 bins, now there are only two: one for the values 0-127 and one for the values 128-255 (note the \u0026lsquo;$\u0026rsquo; sign to indicate \u0026lsquo;rest of the range\u0026rsquo;).\n covergroup cg1 @(posedge clock); cp1: coverpoint gb_iface.instruction; cp_halfs: coverpoint gb_iface.instruction { bins low_half = { [0:127] }; bins high_half = { [128:$] }; } endgroup  \n\nAs can be seen from the example above, this short simulation already provides 100% coverage. All the bins have been hit at least once, so all bins are at 100%.\nAs can be seen from this example, it is not hard to have the simulator report 100% coverage. The art lies in setting correct coverage requirements\n If-and-only-if  Now that\u0026rsquo;s a bit unfair. In this screenshot, cp_halfs reports that 10 times a bin was hit. However, the first 10 clockcycles there is a reset and the valid signal is not high. To fix this issue, there is an if-and-only-if (iff) argument.\n \nThe code below illustrates how the if-an-only-iff keyword can be used. Also note the alternative way of checking which \u0026ldquo;half\u0026rdquo; of the 256-bit space is used. cp_halfs: coverpoint gb_iface.instruction { bins low_half = { [0:127] }; bins high_half = { [128:$] }; }\nc1_halfs_iff: coverpoint gb_iface.instruction[7] iff(gb_iface.valid) { bins low_half = {0}; bins high_half = {1}; } \n  \n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/503_crosscoverage/",
	"title": "503 Cross coverage",
	"tags": [],
	"description": "",
	"content": " Cross coverage In the next example (cg2) the covergroup has two coverpoints: cp_ALU_instruction_type and cp_ALU_instruction_type. The former looks at the type of instruction while the latter focusses on the three least significant bits, which indicated the second operand. Also note that, other than putting 2 coverpoints on a single signal, putting coverpoints is also possible. Additionally the number of times each bin needs to be hit to achieve a 100% goal is also increased to 100.\n covergroup cg2 @(posedge clock); option.at_least = 100; cp_ALU_instruction_type: coverpoint gb_iface.instruction[5] iff(gb_iface.valid) { bins arithmetic = {0}; bins logical = {1}; } cp_ALU_second_operand: coverpoint gb_iface.instruction[2:0] iff(gb_iface.valid); endgroup  \n\nGoing 2D The coverpoints can be seen as follows. A list is made with a certain number of cells (the bins). Every time when the evaluation condition is met, a mark is set in according field of the list. Although that already provides means to evaluate how much testing is done, correlating different coverpoints would provide with even further insights. This is called cross coverage and is also supported by SystemVerilog. Cross coverage can be done between coverpoints, signals, and combinations of both.\n covergroup cg2 @(posedge clock); option.at_least = 100; cp_ALU_instruction_type: coverpoint gb_iface.instruction[5] iff(gb_iface.valid) { bins arithmetic = {0}; bins logical = {1}; } cp_ALU_second_operand: coverpoint gb_iface.instruction[2:0] iff(gb_iface.valid); cx: cross cp_ALU_instruction_type, cp_ALU_second_operand; endgroup  \n\nMaking cross sections Cross coverage bins can be selected from the coverpoints it correlates. This can be achieved by using the keyword binsof. Bins can even be intersected with other ranges. Also logical operators can be used to build combinations like !, \u0026amp;\u0026amp;, and ||.\ncovergroup cg2 @(posedge clock); option.at_least = 100; cp_ALU_instruction_type: coverpoint gb_iface.instruction[5] iff(gb_iface.valid) { bins arithmetic = {0}; bins logical = {1}; } cp_ALU_second_operand: coverpoint gb_iface.instruction[2:0] iff(gb_iface.valid){ bins regB = {0}; bins regC = {1}; bins regD = {2}; bins regE = {3}; bins regH = {4}; bins regL = {5}; bins regHL_ind = {6}; bins regA = {7}; } cx: cross cp_ALU_instruction_type, cp_ALU_second_operand { bins x1 = binsof(cp_ALU_instruction_type.logical) \u0026amp;\u0026amp; binsof(cp_ALU_second_operand.regA); bins x2 = binsof(cp_ALU_instruction_type.logical) \u0026amp;\u0026amp; !binsof(cp_ALU_second_operand.regB); bins x3 = binsof(cp_ALU_instruction_type.arithmetic) || binsof(cp_ALU_second_operand.regA); } endgroup  Running the covergroup above can result as is shown below.\nLet\u0026rsquo;s try to make out any sense of these results. The 2 coverpoints are as before, only with a more sensible naming of the bins. Intersections for the bins are made as follows:\n x1: how many logical instructions are done with regA as operand x2: how many logical instructions are done with another operand than regB x3: how many instructions are arithmetic instructions or are an instruction with regA as operand  With the results of the coverpoints cp_ALU_instruction_type and cp_ALU_second_operand, we can verify the correctness:\n there are 24 arithmetic operations and 21 logical operations. In total there are 45. So this makes sense 😃 summing the number of bins of the second coverpoint also adds up to 45. So this makes sense 😃 for x1, it is reported there are 21 logical operations of which 2 are with regA for x3, we know already there are 24 arithmetic operations, so the number should at least cover these. From x1 we learned that there are 2 logical operations with reg A. This means that x3 should have a count of 24+2 = 26. So this makes sense 😃 for x2, it is reported there are 16 logical operations of which the operand is NOT regB. adding this to the number of logical operations that DO have reg B, gives us 21. This makes sense as this covers ALL the 21 logical operations. 😃  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/504_morebins/",
	"title": "504 More on bins",
	"tags": [],
	"description": "",
	"content": " More on bins The configuration of the bins has a huge influence on the coverage. This makes constraining the bins a delicate job. SystemVerilog therefore offers quite some flexibility to define the bins. Below, a couple of features/techniques are highlighted.\nExplicit bins bins a = {1, 2};  \nBin a is hit when the value is 1 or 2.\n\n\nbins b[3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};  \nBin b is an array of width 3. As the enumeration shows more than 3 values, SystemVerilog dictates an equal distribution of the values to the number of elements in the array: b[0] \u0026lt;= 1, 2, 3; b[1] \u0026lt;= 4, 5, 6; and b[2] \u0026lt;= 7, 8, 9;\n\n\nbins c[3] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  \nIn case of an indivisible number of elements, the final bin takes the remainder: c[0] \u0026lt;= 1, 2, 3; c[1] \u0026lt;= 4, 5, 6; and c[2] \u0026lt;= 7, 8, 9, 10;\n\n\nbins d[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  \nWhen an array is NOT given a size, 1 bin is made for every value in the list.\n\n\nLuckily you don\u0026rsquo;t have to be very explicit. Ranges can be written with a shorter notation. bins e[] = {1, 2, 3, 4, 5};  \nis equivalent to\n\nbins e[] = { [1:5] }; \n\n\nBins for transitions All the bins that were shown up until this point were targeted at certain values (or ranges of values). Next to these options, also transitions can be tallied. The question they aim to answer is: How many times was value X seen, being followed by a value Y ?\ncovergroup cg3 @(posedge clock); cp_ALU_instruction_type: coverpoint gb_iface.instruction[5] iff(gb_iface.valid) { bins arithmetic = {0}; bins logical = {1}; bins arithmetic_after_logical = ( 1=\u0026gt;0 ); bins logical_after_arithmetic = ( 0=\u0026gt;1 ); bins logical_after_logical = ( 0=\u0026gt;0 ); bins arithmetic_after_arithmetic = ( 1=\u0026gt;1 ); } endgroup  \n\n\nIn the example above, coverpoint cg3 again monitors the type of instruction that is being executed in the first two bins arithmetic and logical. The next 4 bins count how often one type of operation is followed by a certain type of operation.\nNote that the sum of all types of operations is 45, but the sum of transitions is only 44.\n Bins for transitions can also be defined in a number of ways.\ncovergroup cg4 @(posedge clock); cp_ALU_instruction_type: coverpoint gb_iface.instruction[5:3] iff(gb_iface.valid) { bins add = {0}; bins adc = {1}; bins sub = {2}; bins sbc = {3}; bins dna = {4}; /* note the name ! */ bins rox = {5}; /* note the name ! */ bins ro = {6}; /* note the name ! */ bins pc = {7}; /* note the name ! */ bins f = ( 2 =\u0026gt; 0 =\u0026gt; 1); } endgroup  \nBin f adds another transition: it counts the number of times a SUB is followed by an ADD which is then followed by an ADC.\n\n\nBin g combines ranges with transitions. It counts how often an arithmetic operation is followed by a logical operation.\n bins g = ([0:3] =\u0026gt; [4:7]);  \n\nIn the next example a shorter way of description is shown. bins h[] = (3=\u0026gt;3=\u0026gt;3=\u0026gt;3=\u0026gt;3);  \nis equivalent to\n\nbins h[] = (3[*5])); \n\n\nNo ordinary headache bins i = (3[* 3:5]);  \nBin i is hit when value 3 is followed more threes, but only when the total is 3, 4, or 5: 3=\u0026gt;3=\u0026gt;3 or 3=\u0026gt;3=\u0026gt;3=\u0026gt;3 or 3=\u0026gt;3=\u0026gt;3=\u0026gt;3=\u0026gt;3 are ok\n\n\nBin j is hit when value 3 is followed two more times but there might be other values within.\n bins j = (3[-\u0026gt;2]);  \n\nFinal word Given the simple DUT that is used for these examples, some of them seem a little overkill. Please, keep in mind that this is purely for educational purpose. To illustrate these concepts it sometimes is easier to simplify too much, but the actual implementations/functionality looses its sense 😉\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/500_coverage/505_assignment/",
	"title": "505 Assignment 4",
	"tags": [],
	"description": "",
	"content": " Assignment 4 This assignment works in an cumulative way. Try to obtain 100% coverage and, upon reaching 100%, stop the simulation. For this exercise it is decided that 100% coverage is reached when:\n at least 100 XORs are executed after immediately after a SBC at least 1000 CPs are executed at least 20 SUB instructions should be done with register E the amount of arithmetic operations should roughly be 3 times the amount of logical operations at least 327 logical instructions are done without register A  To have your simulation halt after achieving 100% coverage, and no longer on a certain number of operations, there is a built-in function $get_coverage( ).  Make sure you only count the instructions if they are valid and no reset is being done !!!\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/600_assertions/",
	"title": "6 Assertions",
	"tags": [],
	"description": "",
	"content": " Assertions Image courtesy: Pexels - Brett Sayles   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/600_assertions/601_assertions/",
	"title": "601 Assertions",
	"tags": [],
	"description": "",
	"content": " Assertions In the previous chapter, covergroups and coverpoints were introduced. These form one type of functional coverage: functional coverage focused on the data. As already mentioned, the other part is functional coverage focused on the control part of a design. This is done through assertions and is the topic of this chapter.\nEverything up until this point has been done outside of the DUT. Assertions are checks that are embedded IN the DUT. These checks give a true or false result based on an assumed property. Although assertions reside IN the DUT, they are a part of verification.\nA natural question would be: Who needs to write assertions: the developer or the verification engineer ?. Well, the answer is simple: both. For the sake of completeness it is mentioned that there are several other languages, next to SystemVerilog Assertions (SVA), that can be used to write assertions, e.g.: e, OVL, and PSL.\nIn short: assertions are used to specify conditions that a programmer assumes are true.\n SystemVerilog provides two types of assertions:\nImmediate Assertions These assertions are evaluated immediately. They have to be placed in a procedural block (in an initial or always block).Example: /* I assume that valid and reset can NEVER be \u0026#39;1\u0026#39; simultaneously */ initial begin no_valid_with_reset: assert (~(valid \u0026amp; reset)) $display(\u0026#34;%m pass\u0026#34;); else $info(\u0026#34;%m fail\u0026#34;); end \nWhen an immediate assertion is evaluated to 1 it is interpreted as true, any other value (0, X, or Z) is interpreted as false.\nImmediate assertions can have a severity: $fatal, $error, $warning, and $info.\nConcurrent Assertions These assertions are evaluated on a set temporal condition. Next to in a procedural block they can also be placed in a module, interface or program definition.Example: /* I assume that valid and reset can NEVER be \u0026#39;1\u0026#39; on a posedge of clock */ no_valid_with_reset_on_rose : assert property ( @(posedge clock)(~(valid \u0026amp; reset))); \nBy now you\u0026rsquo;ll be familiar with posedge and negedge, but there are others means to describe temporal conditions as well:\n $sampled: returns sampled value of expression $rose: returns true on a transition from low to high $fell: returns true on a transition from high to low $stable: returns true if the value of expr did not change    $past: returns past value of expression $onehot: returns true if only one bit of expr is high $onehot0: returns true if at most one bit of expr is high $countones: returns number of 1s in a bit vector expr $isunknown: returns true if bit of expr is X or Z   \nThe difference between posedge and $rose is as follows:  - posedge: 0 -\u0026gt; 1, x -\u0026gt; 1, 0 -\u0026gt; x - $rose: 0 -\u0026gt; 1, x -\u0026gt; 1\n Failing Off course, on the one hand we never want to see an assertion fail; on the other hand, however, it is good to fail because it learns us something. Below is a (pointless) example of an assertion that is expected to fail:\nfailing_assertion : assert property ( @(posedge clock)(~(valid \u0026amp; instruction == 8\u0026#39;h87)));  This failing_assertion assumes that on a rising clock edge it will never occur that valid is high and the instruction == 0x87. Given enough simulation time, this combination is bound to happen. In the simulator, this will be indicated as shown here.\nThe simulator can also give a feedback view on all your assertions.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/600_assertions/602_sequences/",
	"title": "602 Sequences",
	"tags": [],
	"description": "",
	"content": " Sequences Next to defining immediate assertions and concurrent assertions, it is also very valuable if certain sequences can be evaluated. For example, if a condition A is true at a certain moment time, we want to assert that the next clockcycle condition B holds. This type of succession can be described using sequences.\nSequences can be declared in modules, programs, interfaces, \u0026hellip; and can be used in assertions. The example below shows a sequence that:\n if sel is high at a rising edge of the clock and 2 clock cycles later enable is also high   sequence seq1; @(posedge clock) sel ##2 enable; endsequence  \n\n\n   \nIt is pointed out that the number that follows the ## is not interpreted as units of time (e.g. 2 ns), but in timescale sampling points (e.g. `timescale \u0026lt;time_unit\u0026gt;/\u0026lt;time_prescision\u0026gt;). The delay-symbol ## can also be used as an interval, e.g. ##[1:5]; possibly with an open ending, e.g. ##[1:$] (where $ symbolises forever).\nSequences in sequences As the subtitle indicates, sequences can be used in other sequences.\nsequence seq1; @(posedge clock) sel ##2 enable; endsequence sequence seq2; @(posedge clock) clear ##1 seq1 ##1 sel; endsequence  Combining sequences There are a number of ways on which different (parallel) sequences can be combined.   seq1 and seq2 (both must start at the same time)  seq1 or seq2 (both must start at the same time)  seq1 intersect seq2 (both must start and end at the same time)  seq1 within seq2 \n sequence seq1; @(posedge clock) a ##2 b; endsequence sequence seq2; @(posedge clock) c ##1 d ##1 e; endsequence  \n\nHow to incorporate in assertions Sequences can be merged into assertions through properties. The idea is that you can define a property. This could require some code. This property is then used in the assertion to verify.\n Create a boolean expression: sel ##2 enable sel ##2 enable  Make a sequence, using the expression: sequence my_fantastic_sequence; @(posedge clock) sel ##2 enable; endsequence  Make a property, using the sequence property my_fantastic_property; my_fantastic_sequence; endproperty  Assert the property a_bold_assertion_name_goes_here: assert property(my_fantastic_property);   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/600_assertions/603_implications/",
	"title": "603 Implications",
	"tags": [],
	"description": "",
	"content": " Implications The sequences provide the verification engineer with a powerful tool. As with many things, the striking power is very much determined by the creativity and expertise of the wielder. The same holds for implications.\nImplications allow to implement \u0026hellip; well \u0026hellip; implications. For example If x is high, then y must high. The construction consists of an antecedent (the initial condition) and a consequent (the effect).\nAgain there are two different types of implications.\nOverlapping implications In this type of implication the consequent is checked starting from the moment of every non-empty match of the antecedent.\nWriting the implication on the aforementioned example would be done as follows:\nx |-\u0026gt; y;  \nNonoverlapping implications\nIn this type of implication the consequent is checked starting from the next clock tick after each nonempty match of the antecedent.\nWriting the implication on the aforementioned example would be done as follows:\nx |=\u0026gt; y;  \n\nOne more word on implications Implications can be used in properties, but NOT in sequences. The critical reader might see a overlap between the overlapping implication and the immediate assertion. While they might look similar, there is a subtle difference. In case of an overlapping implication where the antecedent is not succeed, the property (in which it is used) is assumed to succeed. A fancy term for this is: vacuous success. In contrast, an immediate assertion will give a warning even if the antecedent is not succeeding.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/700_project/",
	"title": "7 Project",
	"tags": [],
	"description": "",
	"content": " Project The final push in these lab sessions is to apply what has been seen in previous weeks. The examples started on the ALU only and not for long the registerfile of the processor was added. For the project, the DUT is extended again. The added feature is that the load operations are now (almost completely) supported .\nFor the project, this implementation has to be verified.\nThe criteria on what has to be checked, how these are to be checked, and how thoroughly, \u0026hellip; it\u0026rsquo;s all up to you!! \nThe extended functionality Roughly 25% of all the available 8-bit instructions are load-instructions. These instructions have 8 target: regA, regB, regC, regD, regE, regH, regL, and the indirectly addresses position on address HL. Because every target can be loaded with the value of any other target, this gives 8*(8-1) = 56 load instructions. Additionally, there is an option for directly loading an 8-bit value into a target. With these additional 8 instructions, there are 64 load operations.\nREDO IMAGE A few tips and shortcuts  The actual GameBoy processor only has 1 bus interface. This bus provides both instructions and data. For the project we\u0026rsquo;ll be cheating there and assume that (if required) the 8-bit data is present simultaneously with the instruction on a different input. As 16-bit operations were not considered, 16-bit load instructions are also neglected. The indirect addressing of (HL) is ignored. If the value is used to be copied into another register, a hard-coded value of 8\u0026rsquo;h00 is used. Any other indirect addressing is ignored (eg. (BC), (DE), (nn))  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/800_finalremarks/",
	"title": "8 Final remarks",
	"tags": [],
	"description": "",
	"content": " Final remarks Image courtesy: Pexels - Pixabay   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/800_finalremarks/801_final/",
	"title": "801 Final remarks",
	"tags": [],
	"description": "",
	"content": " Final remarks In these labs it was tried to show a different, more professional approach to verification. If there is one take away from these labs it should be: there is more to testing than writing a testbench that successfully executes 1 testvector.\nThrough the use SystemVerilog, all the good of object oriented programming can be brought into hardware verification.\nUsing the coverage capabilities that are by-design in SystemVerilog, is a flexible way to achieve a bug-free, working implementation.\nAssertions were briefly touched, but there is much more to it. Luckily for us, there are working groups like the Open Verification Library (OVL) Working Group. They provide a library of assertion checkers.\nFinally, SystemVerilog is not the terminus, but rather the starting point. The Universal Verification Methodology (UVM) is the de-facto industry standard to verify (large) designs. It is written in SystemVerilog and provides a lot templates for classes like: a generator, a transaction, or a driver.\nWe hope we\u0026rsquo;ve opened your eyes to see how complicated, but also how fascinating verification can be. Let\u0026rsquo;s rise the glass to bug-free hardware designs.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/appendices/",
	"title": "Appendices",
	"tags": [],
	"description": "",
	"content": " Labs A number of labs are described in this section of the course. These help you train the theoretical part of this course. Some exercises are simple and the correct solution is provided on this website. Other exercises require you to write code and simulate it.\nYou can either use Simulation software for this (for example: QuestaSim) or you can use an online platform (for example: https://www.edaplayground.com/)\nQuestaSim - Example: an inverter The exercises in this course are run using Mentor\u0026rsquo;s Questa Sim. For those unfamiliar with this tool, we first give an example using an inverter. Feel free to make a folder in the home directory in which you will do exercises during this course.\n1. Write the HDL for the DUT and the test The DUT is written in a file: inverter.sv `timescale 1ns / 100ps; module inverter (A, B); input A; output B; assign B = ~A; endmodule ```   The test is written in a file: inverter_tb.sv `timescale 1ns / 100ps; module inverter_tb(); logic in, out; inverter my_inverter_inst(in,out); initial begin in = 0; #10 in = 1; #20 in = 0; end endmodule    2. Make a library work QuestaSim requires a library directory to store information about your project. Such a directory, e.g. named “work”, can be generated by the following command:\nvlib work 3. Compiling Before the simulation can be run, both the RTL files and the test files need to be compiled. This can also be done directly from the command line interface:\nvlog -sv inverter.sv vlog -sv inverter_tb.sv or, compiling multiple files in one command:\nvlog -sv src_rtl/inverter.sv src_tb/inverter_tb.sv This typically is the point at which syntax errors are found and displayed. For example:\nvlog -sv inverter.sv -- Compiling module inverter ** Error: (vlog-13069) inverter.sv(7): near \u0026#34;;\u0026#34;: syntax error, unexpected \u0026#39;;\u0026#39;. -- Compiling module inverter_tb End time: 09:54:56 on May 22,2018, Elapsed time: 0:00:00 Errors: 1, Warnings: 0 Note the -sv option: this option enables the SystemVerilog features and keywords.\n 4. The simulator The simulator can be used with a command line interface, or with a graphical user interface (GUI). To use the command line mode, an option “-c” needs to be given.\nvsim -c For the graphical user interface no additional argument is required. The command line interface works (more or less) the same as the “Transcript” window in the graphical user interface.\nIn the GUI waveforms can be examined. To do this, signals have to be added from the “Objects” window by right-clicking on the signal name and selecting “Add Wave”. Another way of achieving this is through the “Transcript” window.\nThe “Transcript” window offers you an interface to use the tool by typing commands. A summarised list of useful commands is given on the cheat page.\ndo files When you\u0026rsquo;re comfortable with the simulator, clicking with a mouse becomes a bit slow. Using the command-line interface can save you a lot of time. However, repeating a lot of typing is cumbersome.\nTo be super efficient, aliases can be used. For example, if you have a 100-line long do file that is called doEverythingForMeAutomagically.do, typing that file name can be improved upon. For those thrill-seekers, the alias command can be nice:\n alias e \u0026ldquo;do doEverythingForMeAutomagically.do\u0026rdquo;\n Now you only have to press two buttons: e and enter.\nGet comfortable with the simulator Try to get the simulation going for the inverter.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/appendices/cheat/",
	"title": "QuestaSim Commanline Cheats",
	"tags": [],
	"description": "",
	"content": " vsim options    Option Description     -c stay in command-line mode   -sv enable SystemVerilog    Transcript commands Compiling    Command Argument Description     vlib work  create a library work   vcom  compile VHDL source   vlog  compile Verilog source   vlog -sv compile SystemVerilog source    Simulating    Command Argument Description     vsim top start simulating entity top    -voptargs=”+acc” top start simulating entity top, and preserve the visibility of objects in the simulator   restart  restart the simulation    -f restart the simulation without the pop-up   run  runs the simulator    10ns runs the simulator for 10 ns   do thisandthat.do execute a do script thisandthat.do   quit -sim close the simulator    Other    Command Argument Description     add wave sim:inverter_tb/out adds the out signal to the waveforms   quit  close QuestaSim    For info on -voptargs=+acc, see: http://www.pldworld.com/_hdl/2/_ref/se_html/manual_html/c_vlog19.html\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/",
	"title": "Chip Design and Verification",
	"tags": [],
	"description": "",
	"content": " Chip Design and Verification Image courtesy: Pexels - Olia Danilevich   div.image_courtesy { text-align: center; font-size: 100%; font-style: italic; }   These webpages will guide you through the lab sessions of Chip Design and Verification. The focus in these labs lies in Verification, using SystemVerilog.\nIn the first section Getting your feet wet the basic concepts of SystemVerilog are explained. The next section Adding some registers does as it says: it adds registers to the design. Climbing the OO ladder handles how the object-oriented nature of SystemVerilog is organised.\nAfter sowing, it becomes time to reap. This is done with Randomisation and Coverage. Finally, the top of the iceberg is scratched on Assertions.\nArmed with those concepts, it\u0026rsquo;s time to put it in actions in the Project.\nIf you have any questions or if you want to discuss certain subjects (with other students or with us), please visit the Toledo Forum.\n\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/course_cdandverif/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]